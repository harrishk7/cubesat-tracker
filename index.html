```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CubeSat Tracker</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- Cesium -->
  <link href="https://unpkg.com/cesium/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />
  <script src="https://unpkg.com/cesium/Build/Cesium/Cesium.js"></script>

  <!-- SGP4 (TLE) -->
  <script src="https://unpkg.com/satellite.js/dist/satellite.min.js"></script>

  <!-- MQTT (WebSocket) -->
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>

  <style>
    html, body, #cesiumContainer {
      width:100%; height:100%;
      margin:0; padding:0;
      overflow:hidden;
      background:#000;
    }

    /* HUD extreme top-left */
    #hud{
      position:absolute;
      left:12px; top:12px;
      z-index:30;
      width: 360px;
      max-height: calc(100vh - 24px);
      overflow:auto;
      padding:12px;
      border-radius:14px;
      background: rgba(0,0,0,0.55);
      border:1px solid rgba(255,255,255,0.14);
      color:#fff;
      font:12px/1.45 system-ui, sans-serif;
      backdrop-filter: blur(8px);
    }

    /* Mini viewer BELOW HUD */
    #miniSatView{
      position:absolute;
      left:12px;
      top: 320px; /* auto-adjusted via JS to sit below HUD */
      width:360px;
      height:220px;
      border-radius:14px;
      overflow:hidden;
      border:1px solid rgba(0,255,255,0.35);
      background:#000;
      z-index:20;
      box-shadow: 0 0 24px rgba(0,255,255,0.18);
      display:none;
    }

    #hud h3 { margin:0 0 10px; font-size:13px; }

    .row { display:flex; gap:8px; margin-bottom:10px; }
    button{
      flex:1; cursor:pointer;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      color:#fff;
      font:12px system-ui, sans-serif;
    }
    button.active{
      border-color: rgba(0,255,255,0.6);
      box-shadow: 0 0 0 1px rgba(0,255,255,0.25) inset;
    }

    .kv { display:flex; justify-content:space-between; gap:12px; margin:4px 0; }
    .k { opacity:0.78; }
    .v { font-variant-numeric: tabular-nums; }

    pre{
      margin:10px 0 0;
      padding:8px 10px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      white-space: pre-wrap;
      word-break: break-word;
      font-size: 11px;
      line-height: 1.35;
    }

    .cesium-viewer-bottom { display:none !important; }
  </style>
</head>

<body>
  <div id="cesiumContainer"></div>

  <div id="hud">
    <h3>CubeSat Tracker</h3>

    <div class="row">
      <button id="btnSat" class="active">Sat POV</button>
      <button id="btnWorld">World POV</button>
      <button id="btn2d">2D POV</button>
    </div>

    <!-- 2D options (shown only when in 2D) -->
    <div class="row" id="row2dOpts" style="display:none;">
      <button id="btn2dFollow">2D: Trace Sat</button>
      <button id="btn2dZoom" class="active">2D: Zoom Out</button>
    </div>

    <div class="kv"><div class="k">Status</div><div class="v" id="st">Booting…</div></div>
    <div class="kv"><div class="k">UTC</div><div class="v" id="utc">—</div></div>

    <div style="height:8px"></div>
    <div class="kv"><div class="k">Lat</div><div class="v" id="lat">—</div></div>
    <div class="kv"><div class="k">Lon</div><div class="v" id="lon">—</div></div>
    <div class="kv"><div class="k">Alt</div><div class="v" id="alt">—</div></div>
    <div class="kv"><div class="k">Speed</div><div class="v" id="spd">—</div></div>

    <div style="height:8px"></div>
    <div class="kv"><div class="k">MQTT</div><div class="v" id="mq">—</div></div>
    <div class="kv"><div class="k">TLE Age</div><div class="v" id="tleAge">—</div></div>

    <pre id="tleBox">Waiting for TLE…</pre>
  </div>

  <div id="miniSatView"></div>

<script>
(async function () {

  /* ===================== CONFIG ===================== */
  // TIP: When serving locally with python http.server, prefer "./assets/..." not "/assets/..."
  const MODEL_URI = "./assets/CubeSat.glb";

  const MQTT_URLS   = ["wss://broker.hivemq.com:8884/mqtt"];
  const TOPIC_TLE   = "cubesat/tle";
  const TOPIC_IMU   = "cubesat/attitude";   // roll/pitch/yaw JSON

  const INDIA_HOME = { lon: 78.9629, lat: 20.5937, height: 8.0e6 };
  const WORLD_ALT  = 3.2e7;

  // ✅ Longer + smoother orbit trail
  const SAMPLE_PAST_SEC   = 70 * 60;
  const SAMPLE_FUTURE_SEC = 70 * 60;

  // ✅ Denser sampling = smooth trail
  const SAMPLE_STEP_SEC   = 1;

  // keep appending a little ahead
  const APPEND_AHEAD_SEC  = 90;
  const APPEND_EVERY_MS   = 800;

  // coverage smoothing (EMA)
  const MIN_ELEV_DEG = 10;
  const COVER_ALPHA  = 0.22;
  const COVER_SMOOTH = 0.15;

  // IMU state (degrees)
  const imu = { roll: 0, pitch: 0, yaw: 0 };

  // Flip signs if needed
  const IMU_SIGN = { roll: +1, pitch: +1, yaw: +1 };

  // 2D behavior controls
  let follow2D = false;              // default: zoom out
  const FOLLOW2D_HEIGHT_M = 1.8e6;   // closer when tracing
  const ZOOM2D_HEIGHT_M   = 2.4e7;   // wider map view when zoomed out

  /* ===================== DOM ===================== */
  const el = (id) => document.getElementById(id);
  const stEl = el("st"), utcEl = el("utc"), latEl = el("lat"), lonEl = el("lon"),
        altEl = el("alt"), spdEl = el("spd"), mqEl = el("mq"),
        tleAgeEl = el("tleAge"), tleBox = el("tleBox");

  const btnSat = el("btnSat"), btnWorld = el("btnWorld"), btn2d = el("btn2d");
  const row2dOpts = el("row2dOpts");
  const btn2dFollow = el("btn2dFollow");
  const btn2dZoom   = el("btn2dZoom");

  const hud = el("hud");
  const miniDiv = el("miniSatView");

  function setActive(btn){
    [btnSat, btnWorld, btn2d].forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
  }

  function set2dActive(btn){
    [btn2dFollow, btn2dZoom].forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
  }

  function setStatus(s){ stEl.textContent = s; }
  function nowUTCString(){ return new Date().toISOString().replace("T"," ").replace("Z"," UTC"); }

  function showMiniView(show){
    miniDiv.style.display = show ? "block" : "none";
    layoutMini();
  }

  function layoutMini(){
    const r = hud.getBoundingClientRect();
    miniDiv.style.top = (Math.round(r.bottom) + 12) + "px";
  }
  window.addEventListener("resize", layoutMini);

  /* ===================== CESIUM MAIN VIEWER ===================== */
  const viewer = new Cesium.Viewer("cesiumContainer", {
    animation: false,
    timeline: false,
    baseLayerPicker: false,
    sceneModePicker: false,
    geocoder: false,
    navigationHelpButton: false,
    fullscreenButton: false,
    infoBox: false,
    selectionIndicator: false,
    homeButton: true,
    requestRenderMode: true,
    maximumRenderTimeChange: 0.25
  });

  viewer.scene.globe.enableLighting = true;
  viewer.camera.setView({
    destination: Cesium.Cartesian3.fromDegrees(INDIA_HOME.lon, INDIA_HOME.lat, INDIA_HOME.height)
  });

  viewer.homeButton.viewModel.command.beforeExecute.addEventListener((e) => {
    e.cancel = true;
    viewer.camera.flyTo({
      destination: Cesium.Cartesian3.fromDegrees(INDIA_HOME.lon, INDIA_HOME.lat, INDIA_HOME.height),
      duration: 1.1
    });
  });

  viewer.clock.clockRange = Cesium.ClockRange.UNBOUNDED;
  viewer.clock.multiplier = 1;

  /* ===================== MINI VIEWER ===================== */
  const miniViewer = new Cesium.Viewer("miniSatView", {
    animation: false,
    timeline: false,
    baseLayerPicker: false,
    sceneModePicker: false,
    geocoder: false,
    navigationHelpButton: false,
    fullscreenButton: false,
    infoBox: false,
    selectionIndicator: false,
    homeButton: false,
    requestRenderMode: true,
    maximumRenderTimeChange: 0.25
  });

  miniViewer.scene.backgroundColor = Cesium.Color.BLACK;
  miniViewer.scene.skyBox = undefined;
  miniViewer.scene.skyAtmosphere = undefined;
  miniViewer.scene.globe.enableLighting = true;

  /* ===================== ORBIT (SGP4) ===================== */
  let satName = "CubeSat";
  let satrec = null;
  let tleReceivedAt = null;

  function parseTLEMessage(msg) {
    try {
      const j = JSON.parse(msg);
      if (j && j.line1 && j.line2) return { name: j.name || "SAT", l1: j.line1.trim(), l2: j.line2.trim() };
    } catch {}
    const lines = msg.split("\n").map(s=>s.trim()).filter(Boolean);
    if (lines.length >= 3) return { name: lines[0], l1: lines[1], l2: lines[2] };
    if (lines.length >= 2) return { name: "SAT", l1: lines[0], l2: lines[1] };
    return null;
  }

  function propagateLLA(date) {
    if (!satrec) return null;

    const pv = satellite.propagate(satrec, date);
    if (!pv || !pv.position || !pv.velocity) return null;

    const gmst = satellite.gstime(date);
    const gd = satellite.eciToGeodetic(pv.position, gmst);

    const lat = Cesium.Math.toDegrees(gd.latitude);
    const lon = Cesium.Math.toDegrees(gd.longitude);
    const altKm = gd.height;

    const v = pv.velocity;
    const speedKmS = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);

    return { lat, lon, altKm, speedKmS };
  }

  function llaToCartesian(lat, lon, altKm){
    return Cesium.Cartesian3.fromDegrees(lon, lat, altKm * 1000);
  }

  function coverageRadiusMeters(altMeters, minElevDeg) {
    const R = 6378137.0;
    const h = Math.max(0, altMeters);
    const e = Cesium.Math.toRadians(minElevDeg);
    const term = (R / (R + h)) * Math.cos(e);
    const psi = Math.acos(Math.min(1, Math.max(-1, term))) - e;
    return Math.max(0, R * psi);
  }

  /* ===================== SAMPLED POSITION ===================== */
  let sampledPos = new Cesium.SampledPositionProperty();
  sampledPos.setInterpolationOptions({
    interpolationDegree: 5,
    interpolationAlgorithm: Cesium.LagrangePolynomialApproximation
  });

  let lastSampledTo = null;

  // entity refs
  let satEntity = null;
  let miniSatEntity = null;

  function nowDateFromClock(){
    return Cesium.JulianDate.toDate(viewer.clock.currentTime);
  }

  function clearSamplesCompat(){
    if (sampledPos && typeof sampledPos.removeAllSamples === "function") {
      sampledPos.removeAllSamples();
      return;
    }

    const fresh = new Cesium.SampledPositionProperty();
    fresh.setInterpolationOptions({
      interpolationDegree: 5,
      interpolationAlgorithm: Cesium.LagrangePolynomialApproximation
    });
    sampledPos = fresh;

    if (satEntity) satEntity.position = sampledPos;
    if (miniSatEntity) miniSatEntity.position = sampledPos;
  }

  function syncClocksTo(centerDate){
    const center = Cesium.JulianDate.fromDate(centerDate);

    viewer.clock.currentTime = center.clone();
    viewer.clock.startTime   = Cesium.JulianDate.addSeconds(center, -SAMPLE_PAST_SEC, new Cesium.JulianDate());
    viewer.clock.stopTime    = Cesium.JulianDate.addSeconds(center,  SAMPLE_FUTURE_SEC, new Cesium.JulianDate());
    viewer.clock.clockRange  = Cesium.ClockRange.UNBOUNDED;
    viewer.clock.shouldAnimate = true;

    miniViewer.clock.currentTime = center.clone();
    miniViewer.clock.startTime   = viewer.clock.startTime.clone();
    miniViewer.clock.stopTime    = viewer.clock.stopTime.clone();
    miniViewer.clock.clockRange  = Cesium.ClockRange.UNBOUNDED;
    miniViewer.clock.shouldAnimate = true;
  }

  function clearAndSeedSamples(centerDate){
    clearSamplesCompat();
    lastSampledTo = null;

    syncClocksTo(centerDate);

    const center = Cesium.JulianDate.fromDate(centerDate);
    for (let t = -SAMPLE_PAST_SEC; t <= SAMPLE_FUTURE_SEC; t += SAMPLE_STEP_SEC) {
      const d = new Date(centerDate.getTime() + t*1000);
      const s = propagateLLA(d);
      if (!s) continue;
      const jt = Cesium.JulianDate.addSeconds(center, t, new Cesium.JulianDate());
      sampledPos.addSample(jt, llaToCartesian(s.lat, s.lon, s.altKm));
      lastSampledTo = jt;
    }

    viewer.scene.requestRender();
    miniViewer.scene.requestRender();
  }

  function appendSamplesAhead(){
    if (!satrec || !lastSampledTo) return;

    // ✅ IMPORTANT: use viewer clock time (not wall clock) to avoid gaps
    const now = viewer.clock.currentTime;
    const target = Cesium.JulianDate.addSeconds(now, APPEND_AHEAD_SEC, new Cesium.JulianDate());

    while (Cesium.JulianDate.lessThan(lastSampledTo, target)) {
      const next = Cesium.JulianDate.addSeconds(lastSampledTo, SAMPLE_STEP_SEC, new Cesium.JulianDate());
      const d = Cesium.JulianDate.toDate(next);
      const s = propagateLLA(d);
      if (s) sampledPos.addSample(next, llaToCartesian(s.lat, s.lon, s.altKm));
      lastSampledTo = next;
    }

    viewer.scene.requestRender();
    miniViewer.scene.requestRender();
  }

  /* ===================== ORIENTATION (IMU -> CESIUM) ===================== */
  const imuOrientation = new Cesium.CallbackProperty((time) => {
    const pos = sampledPos.getValue(time, new Cesium.Cartesian3());
    if (!pos) return Cesium.Quaternion.IDENTITY;

    const h = Cesium.Math.toRadians((imu.yaw   || 0) * IMU_SIGN.yaw);
    const p = Cesium.Math.toRadians((imu.pitch || 0) * IMU_SIGN.pitch);
    const r = Cesium.Math.toRadians((imu.roll  || 0) * IMU_SIGN.roll);

    const hpr = new Cesium.HeadingPitchRoll(h, p, r);
    return Cesium.Transforms.headingPitchRollQuaternion(pos, hpr);
  }, false);

  /* ===================== SAT ENTITY ===================== */
  satEntity = viewer.entities.add({
    name: "CubeSat",
    position: sampledPos,
    orientation: imuOrientation,
    model: {
      uri: MODEL_URI,
      minimumPixelSize: 70,
      maximumScale: 80000,
      shadows: Cesium.ShadowMode.DISABLED
    },
    label: {
      text: new Cesium.CallbackProperty(() => satName, false),
      font: "14px system-ui",
      fillColor: Cesium.Color.WHITE,
      outlineColor: Cesium.Color.BLACK,
      outlineWidth: 3,
      style: Cesium.LabelStyle.FILL_AND_OUTLINE,
      pixelOffset: new Cesium.Cartesian2(14, -14),
      distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 5.0e8)
    },
    path: {
      show: true,
      leadTime: SAMPLE_FUTURE_SEC,
      trailTime: SAMPLE_PAST_SEC,
      width: 2,
      // ✅ Lower = smoother. This samples the position property along the path.
      resolution: 1,
      material: new Cesium.PolylineGlowMaterialProperty({
        glowPower: 0.18,
        color: Cesium.Color.CYAN.withAlpha(0.9)
      })
    }
  });

  /* ===================== MINI SAT ENTITY ===================== */
  miniSatEntity = miniViewer.entities.add({
    position: sampledPos,
    orientation: imuOrientation,
    model: {
      uri: MODEL_URI,
      minimumPixelSize: 90,
      maximumScale: 120000,
      shadows: Cesium.ShadowMode.DISABLED
    }
  });
  miniViewer.trackedEntity = miniSatEntity;

  /* ===================== COVERAGE (NO FLICKER) ===================== */
  let covLon = 0, covLat = 0;
  let covRadiusSmoothM = 0;

  viewer.entities.add({
    position: new Cesium.CallbackProperty(
      () => Cesium.Cartesian3.fromDegrees(covLon, covLat, 10), false
    ),
    ellipse: {
      semiMajorAxis: new Cesium.CallbackProperty(() => covRadiusSmoothM, false),
      semiMinorAxis: new Cesium.CallbackProperty(() => covRadiusSmoothM, false),
      material: Cesium.Color.YELLOW.withAlpha(COVER_ALPHA),
      outline: true,
      outlineColor: Cesium.Color.YELLOW.withAlpha(0.7),
      height: 10,
      extrudedHeight: 10
    }
  });

  /* ===================== HUD LOOP ===================== */
  function updateHUD(){
    utcEl.textContent = nowUTCString();

    if (!satrec) {
      latEl.textContent = lonEl.textContent = altEl.textContent = spdEl.textContent = "—";
      tleAgeEl.textContent = "—";
      return;
    }

    const s = propagateLLA(nowDateFromClock());
    if (!s) return;

    latEl.textContent = s.lat.toFixed(5) + "°";
    lonEl.textContent = s.lon.toFixed(5) + "°";
    altEl.textContent = s.altKm.toFixed(1) + " km";
    spdEl.textContent = s.speedKmS.toFixed(3) + " km/s";

    if (tleReceivedAt) {
      tleAgeEl.textContent = Math.floor((Date.now() - tleReceivedAt.getTime())/1000) + " s";
    }

    covLon = s.lon;
    covLat = s.lat;
    const targetR = coverageRadiusMeters(s.altKm * 1000, MIN_ELEV_DEG);
    covRadiusSmoothM += (targetR - covRadiusSmoothM) * COVER_SMOOTH;

    // Continuous follow in 2D
    if (viewer.scene.mode === Cesium.SceneMode.SCENE2D && follow2D) {
      viewer.camera.setView({
        destination: Cesium.Cartesian3.fromDegrees(s.lon, s.lat, FOLLOW2D_HEIGHT_M)
      });
    }

    viewer.scene.requestRender();
    miniViewer.scene.requestRender();
    layoutMini();
  }

  setInterval(updateHUD, 220);
  setInterval(appendSamplesAhead, APPEND_EVERY_MS);

  /* ===================== CAMERA / POV ===================== */
  function flyToSatGlobalView(){
    viewer.flyTo(satEntity, {
      duration: 1.1,
      offset: new Cesium.HeadingPitchRange(
        Cesium.Math.toRadians(20),
        Cesium.Math.toRadians(-35),
        WORLD_ALT
      )
    });
  }

  function fly2DZoomOut(){
    viewer.camera.flyTo({
      destination: Cesium.Cartesian3.fromDegrees(INDIA_HOME.lon, INDIA_HOME.lat, ZOOM2D_HEIGHT_M),
      duration: 0.9
    });
  }

  function setSatPOV(){
    setActive(btnSat);
    row2dOpts.style.display = "none";
    viewer.scene.morphTo3D(0.6);
    viewer.trackedEntity = satEntity;
    showMiniView(false);
    setStatus("Sat POV ✅");
    viewer.scene.requestRender();
  }

  function setWorldPOV(){
    setActive(btnWorld);
    row2dOpts.style.display = "none";
    viewer.scene.morphTo3D(0.6);
    viewer.trackedEntity = undefined;
    showMiniView(true);
    flyToSatGlobalView();
    setStatus("World POV ✅");
  }

  function set2DPOV(){
    setActive(btn2d);
    viewer.trackedEntity = undefined;
    viewer.scene.morphTo2D(0.8);
    row2dOpts.style.display = "flex";

    if (follow2D) {
      set2dActive(btn2dFollow);
      showMiniView(false); // mini OFF while tracing
      setStatus("2D Trace ✅");
    } else {
      set2dActive(btn2dZoom);
      showMiniView(true); // mini ON only in zoom-out
      setStatus("2D Zoom Out ✅");
      setTimeout(fly2DZoomOut, 350);
    }

    viewer.scene.requestRender();
  }

  // 2D option buttons
  btn2dFollow.onclick = () => {
    follow2D = true;
    set2dActive(btn2dFollow);
    showMiniView(false);
    setStatus("2D Trace ✅");
    viewer.scene.requestRender();
  };

  btn2dZoom.onclick = () => {
    follow2D = false;
    set2dActive(btn2dZoom);
    showMiniView(true);
    setStatus("2D Zoom Out ✅");
    fly2DZoomOut();
  };

  btnSat.onclick = setSatPOV;
  btnWorld.onclick = setWorldPOV;
  btn2d.onclick = set2DPOV;

  setSatPOV();
  layoutMini();

  /* ===================== APPLY TLE ===================== */
  function setTLE(name, l1, l2){
    satName = name || "SAT";
    tleReceivedAt = new Date();
    satrec = satellite.twoline2satrec(l1, l2);

    tleBox.textContent = `${satName}\n${l1}\n${l2}`;
    setStatus("TLE loaded ✅");

    clearAndSeedSamples(new Date());

    if (btnWorld.classList.contains("active")) setWorldPOV();
    else if (btn2d.classList.contains("active")) set2DPOV();
    else setSatPOV();
  }

  /* ===================== MQTT ===================== */
  setStatus("Connecting MQTT…");
  mqEl.textContent = "Connecting…";

  const mqttClient = mqtt.connect(MQTT_URLS[0], {
    keepalive: 60,
    reconnectPeriod: 2000,
    connectTimeout: 15000,
    clean: true
  });

  mqttClient.on("connect", () => {
    mqEl.textContent = "Connected ✅";
    setStatus("MQTT connected ✅");

    mqttClient.subscribe([TOPIC_TLE, TOPIC_IMU], (err) => {
      setStatus(err ? "Subscribe error ❌" : ("Subscribed ✅ " + TOPIC_TLE + " + " + TOPIC_IMU));
    });
  });

  mqttClient.on("message", (topic, payload) => {
    const msg = payload.toString();

    // TLE
    if (topic === TOPIC_TLE) {
      const tle = parseTLEMessage(msg);
      if (!tle) { setStatus("Bad TLE format ❌"); return; }
      setTLE(tle.name, tle.l1, tle.l2);
      return;
    }

    // IMU attitude (roll/pitch/yaw)
    if (topic === TOPIC_IMU) {
      try {
        const data = JSON.parse(msg);
        const r = Number(data.roll  ?? data.Roll  ?? data.roll_deg  ?? data.rollDeg);
        const p = Number(data.pitch ?? data.Pitch ?? data.pitch_deg ?? data.pitchDeg);
        const y = Number(data.yaw   ?? data.Yaw   ?? data.yaw_deg   ?? data.yawDeg);

        if (!Number.isNaN(r)) imu.roll = r;
        if (!Number.isNaN(p)) imu.pitch = p;
        if (!Number.isNaN(y)) imu.yaw = y;

        viewer.scene.requestRender();
        miniViewer.scene.requestRender();
      } catch (e) {}
    }
  });

  mqttClient.on("reconnect", () => { mqEl.textContent = "Reconnecting…"; setStatus("MQTT reconnecting…"); });
  mqttClient.on("close", () => { mqEl.textContent = "Disconnected"; setStatus("MQTT disconnected"); });
  mqttClient.on("error", (e) => { console.log("MQTT error", e); mqEl.textContent = "Error"; setStatus("MQTT error ❌"); });

})();
</script>
</body>
</html>
