<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CubeSat Tracker</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- Cesium -->
  <link href="https://unpkg.com/cesium/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />
  <script src="https://unpkg.com/cesium/Build/Cesium/Cesium.js"></script>

  <!-- SGP4 -->
  <script src="https://unpkg.com/satellite.js/dist/satellite.min.js"></script>

  <!-- MQTT (WebSocket) -->
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>

  <style>
    :root{
      --bg0: rgba(0,0,0,0.55);
      --bg1: rgba(6,18,28,0.78);
      --panel: rgba(3,16,26,0.72);
      --panel2: rgba(2,12,20,0.76);
      --line: rgba(0,255,255,0.22);
      --line2: rgba(255,255,255,0.10);
      --cyan: rgba(0,255,255,0.92);
      --cyan2: rgba(0,255,255,0.55);
      --txt: rgba(240,255,255,0.92);
      --muted: rgba(180,220,220,0.58);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --ui: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    html, body, #cesiumContainer {
      width:100%; height:100%;
      margin:0; padding:0;
      overflow:hidden;
      background:#000;
    }

    /* =========================
       HUD (Mission Control style)
       ========================= */
    #hud{
      position:absolute;
      left:14px; top:14px;
      z-index:30;
      width: 420px;
      max-height: calc(100vh - 28px);
      overflow:auto;
      padding:14px 14px 12px;
      border-radius:16px;

      background: linear-gradient(180deg, rgba(5,24,36,0.82), rgba(2,14,22,0.78));
      border: 1px solid rgba(0,255,255,0.28);
      box-shadow:
        0 0 0 1px rgba(0,255,255,0.06) inset,
        0 0 30px rgba(0,255,255,0.10),
        0 18px 60px rgba(0,0,0,0.55);
      backdrop-filter: blur(10px);

      color: var(--txt);
      font: 12px/1.45 var(--ui);
    }

    /* header row */
    #hudHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom:12px;
    }

    #hudTitleWrap{
      display:flex;
      align-items:center;
      gap:10px;
      min-width: 0;
    }

    .hexDot{
      width:10px; height:10px;
      background: var(--cyan);
      box-shadow: 0 0 16px rgba(0,255,255,0.50);
      clip-path: polygon(25% 4%, 75% 4%, 96% 50%, 75% 96%, 25% 96%, 4% 50%);
      flex: 0 0 auto;
    }

    #hudTitle{
      margin:0;
      font: 700 14px/1.1 var(--mono);
      letter-spacing: 0.22em;
      text-transform: uppercase;
      color: rgba(0,255,255,0.80);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #hudHeaderRight{
      display:flex;
      align-items:center;
      gap:10px;
      flex: 0 0 auto;
    }

    /* LIVE pill */
    #livePill{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:6px 12px;
      border-radius:999px;
      border:1px solid rgba(0,255,255,0.30);
      background: rgba(0,0,0,0.18);
      box-shadow: 0 0 0 1px rgba(0,255,255,0.05) inset;
      font: 700 11px/1 var(--mono);
      letter-spacing: 0.14em;
      text-transform: uppercase;
      user-select:none;
      white-space:nowrap;
      color: rgba(230,255,255,0.88);
    }
    #liveDot{
      width:8px; height:8px;
      border-radius:999px;
      background: rgba(180,180,180,0.95);
      box-shadow: 0 0 14px rgba(180,180,180,0.35);
    }
    #liveTxt{ opacity:0.94; }

    /* little "bars" icon */
    #hudBars{
      width:34px; height:26px;
      border-radius:8px;
      border:1px solid rgba(0,255,255,0.28);
      background: rgba(0,0,0,0.14);
      display:flex;
      align-items:center;
      justify-content:center;
      box-shadow: 0 0 0 1px rgba(0,255,255,0.05) inset;
    }
    #hudBars i{
      display:block;
      width:18px; height:12px;
      position:relative;
      opacity:0.95;
    }
    #hudBars i::before{
      content:"";
      position:absolute; inset:0;
      background:
        linear-gradient(to right,
          rgba(0,255,255,0.85) 0 3px, transparent 3px 6px,
          rgba(0,255,255,0.70) 6px 9px, transparent 9px 12px,
          rgba(0,255,255,0.55) 12px 15px, transparent 15px 18px);
      filter: drop-shadow(0 0 6px rgba(0,255,255,0.18));
    }

    /* Buttons rows */
    .btnRow{
      display:flex;
      gap:10px;
      margin-bottom:12px;
    }

    .mcBtn{
      flex:1;
      cursor:pointer;
      padding:10px 12px;
      border-radius:10px;
      border:1px solid rgba(0,255,255,0.22);
      background: rgba(0,0,0,0.14);
      color: rgba(0,255,255,0.72);
      font: 800 12px/1 var(--mono);
      letter-spacing: 0.14em;
      text-transform: uppercase;
      box-shadow:
        0 0 0 1px rgba(0,255,255,0.03) inset,
        0 10px 20px rgba(0,0,0,0.18);
      transition: transform 80ms ease, border-color 120ms ease, box-shadow 120ms ease, color 120ms ease, background 120ms ease;
      user-select:none;
    }
    .mcBtn:hover{
      transform: translateY(-1px);
      border-color: rgba(0,255,255,0.34);
      box-shadow:
        0 0 0 1px rgba(0,255,255,0.06) inset,
        0 0 22px rgba(0,255,255,0.10);
      color: rgba(0,255,255,0.85);
    }
    .mcBtn.active{
      background: rgba(0,255,255,0.08);
      border-color: rgba(0,255,255,0.55);
      color: rgba(0,255,255,0.95);
      box-shadow:
        0 0 0 1px rgba(0,255,255,0.12) inset,
        0 0 26px rgba(0,255,255,0.14);
    }

    /* Data cards */
    .card{
      margin-top: 10px;
      padding: 12px 12px;
      border-radius: 12px;
      background: linear-gradient(180deg, rgba(0,0,0,0.18), rgba(0,0,0,0.10));
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 0 0 1px rgba(0,255,255,0.05) inset;
      position: relative;
    }
    .card::before{
      content:"";
      position:absolute;
      left:0; top:10px; bottom:10px;
      width:3px;
      border-radius: 3px;
      background: rgba(0,255,255,0.35);
      box-shadow: 0 0 14px rgba(0,255,255,0.12);
    }
    .rows{
      display:flex;
      flex-direction:column;
      gap:0;
    }
    .rowKV{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 14px;
      padding: 9px 0;
      border-top: 1px solid rgba(255,255,255,0.06);
    }
    .rowKV:first-child{ border-top: none; padding-top: 2px; }
    .k{
      font: 800 11px/1 var(--mono);
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: rgba(0,255,255,0.55);
      padding-left: 8px;
    }
    .v{
      font: 700 12px/1.1 var(--mono);
      letter-spacing: 0.05em;
      color: rgba(0,255,255,0.88);
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
      padding-right: 2px;
    }
    .v.dim{ color: rgba(230,255,255,0.82); letter-spacing: 0.03em; }

    /* TLE box */
    #tleBox{
      margin: 12px 0 0;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(0,0,0,0.16);
      border: 1px solid rgba(0,255,255,0.12);
      box-shadow: 0 0 0 1px rgba(0,255,255,0.03) inset;
      color: rgba(225,255,255,0.85);
      font: 12px/1.35 var(--mono);
      white-space: pre-wrap;
      word-break: break-word;
    }

    /* Mini view */
    #miniSatView{
      position:absolute;
      left:14px;
      top: 340px;
      width:420px;
      height:240px;
      border-radius:16px;
      overflow:hidden;
      border:1px solid rgba(0,255,255,0.28);
      background:#000;
      z-index:20;
      box-shadow: 0 0 30px rgba(0,255,255,0.10);
      display:none;
    }

    /* =========================
       PASS PLANNER MODAL (match screenshot)
       ========================= */
    #modal{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index:100;
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(7px);
    }
    #modalCard{
      width:min(760px, calc(100vw - 28px));
      border-radius:18px;
      border:1px solid rgba(0,255,255,0.28);
      background: linear-gradient(180deg, rgba(5,24,36,0.86), rgba(2,14,22,0.84));
      box-shadow:
        0 0 0 1px rgba(0,255,255,0.06) inset,
        0 0 40px rgba(0,255,255,0.10),
        0 18px 70px rgba(0,0,0,0.65);
      color:#fff;
      overflow:hidden;
      font: 12px/1.45 var(--ui);
    }
    #modalTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 14px 14px 12px;
      border-bottom: 1px solid rgba(0,255,255,0.16);
    }
    #modalTitleWrap{
      display:flex;
      align-items:center;
      gap:10px;
      min-width: 0;
    }
    #modalTitle{
      margin:0;
      font: 800 14px/1.1 var(--mono);
      letter-spacing: 0.22em;
      text-transform: uppercase;
      color: rgba(0,255,255,0.78);
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    #modalClose{
      cursor:pointer;
      width:44px;
      height:34px;
      border-radius:10px;
      border:1px solid rgba(0,255,255,0.22);
      background: rgba(0,0,0,0.14);
      color: rgba(230,255,255,0.88);
      font: 900 16px/1 var(--mono);
      display:flex;
      align-items:center;
      justify-content:center;
      box-shadow: 0 0 0 1px rgba(0,255,255,0.05) inset;
      user-select:none;
    }
    #modalClose:hover{
      border-color: rgba(0,255,255,0.36);
      box-shadow: 0 0 22px rgba(0,255,255,0.12);
    }

    #modalBody{
      padding: 14px;
    }
    .passBlock{
      padding: 10px 0 0;
    }
    .passSep{
      height:1px;
      background: rgba(0,255,255,0.14);
      margin: 14px 0;
    }
    .passRow{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:14px;
      padding: 9px 10px;
      border-radius: 10px;
      background: rgba(0,0,0,0.12);
      border: 1px solid rgba(255,255,255,0.04);
      margin-bottom: 8px;
      box-shadow: 0 0 0 1px rgba(0,255,255,0.03) inset;
    }
    .passK{
      font: 800 11px/1 var(--mono);
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: rgba(0,255,255,0.55);
    }
    .passV{
      font: 700 12px/1.2 var(--mono);
      letter-spacing: 0.05em;
      color: rgba(0,255,255,0.88);
      font-variant-numeric: tabular-nums;
      text-align:right;
      white-space: nowrap;
    }

    /* Hide Cesium footer */
    .cesium-viewer-bottom { display:none !important; }
  </style>
</head>

<body>
  <div id="cesiumContainer"></div>

  <div id="modal">
    <div id="modalCard" role="dialog" aria-modal="true">
      <div id="modalTop">
        <div id="modalTitleWrap">
          <span class="hexDot"></span>
          <h4 id="modalTitle">GROUND STATION • PASS PLANNER</h4>
        </div>
        <button id="modalClose" aria-label="Close">×</button>
      </div>
      <div id="modalBody">Loading…</div>
    </div>
  </div>

  <div id="hud">
    <div id="hudHeader">
      <div id="hudTitleWrap">
        <span class="hexDot"></span>
        <h3 id="hudTitle">MISSION CONTROL</h3>
      </div>

      <div id="hudHeaderRight">
        <div id="livePill" title="Streaming status">
          <span id="liveDot"></span>
          <span id="liveTxt">BOOT</span>
        </div>
        <div id="hudBars" title="Status">
          <i></i>
        </div>
      </div>
    </div>

    <div class="btnRow">
      <button id="btnSat" class="mcBtn active">SAT POV</button>
      <button id="btnWorld" class="mcBtn">WORLD POV</button>
      <button id="btn2d" class="mcBtn">2D POV</button>
    </div>

    <div class="btnRow" id="row2dOpts" style="display:none;">
      <button id="btn2dFollow" class="mcBtn">TRACE SAT</button>
      <button id="btn2dZoom" class="mcBtn active">ZOOM OUT</button>
    </div>

    <div class="card">
      <div class="rows">
        <div class="rowKV"><div class="k">STATUS</div><div class="v dim" id="st">Booting…</div></div>
        <div class="rowKV"><div class="k">UTC</div><div class="v" id="utc">—</div></div>
        <div class="rowKV"><div class="k">MET</div><div class="v" id="met">—</div></div>
      </div>
    </div>

    <div class="card" style="margin-top:12px;">
      <div class="rows">
        <div class="rowKV"><div class="k">LATITUDE</div><div class="v" id="lat">—</div></div>
        <div class="rowKV"><div class="k">LONGITUDE</div><div class="v" id="lon">—</div></div>
        <div class="rowKV"><div class="k">ALTITUDE</div><div class="v" id="alt">—</div></div>
        <div class="rowKV"><div class="k">VELOCITY</div><div class="v" id="spd">—</div></div>
      </div>
    </div>

    <div class="card" style="margin-top:12px;">
      <div class="rows">
        <div class="rowKV"><div class="k">DATA ING.</div><div class="v dim" id="mq">—</div></div>
        <div class="rowKV"><div class="k">TLE AGE</div><div class="v" id="tleAge">—</div></div>
      </div>
    </div>

    <div id="tleBox">Waiting for TLE…</div>
  </div>

  <div id="miniSatView"></div>

<script>
(async function () {
  "use strict";

  /* ===================== CONFIG ===================== */
  const MODEL_URI = "./assets/CubeSat.glb";

  /* ===================== PERF (butter smooth) ===================== */
  const PERF = {
    STATE_HZ: 25,
    COVER_HZ: 8,
    SAMPLE_STEP_SEC: 5,
    ENABLE_WORLD_TERRAIN: false,
    ENABLE_LIGHTING: true,
    DEPTH_TEST_TERRAIN: false,
    MAX_SSE: 2.0,
    TILE_CACHE: 600,
    FXAA: true
  };

  /* ===== HiveMQ Cloud (Browser must use WSS) ===== */
  const MQTT_HOST = "4bde42256ac0461d872447cc72b1a99f.s1.eu.hivemq.cloud";
  const MQTT_WS_PORT = 8884;
  const MQTT_WSS_URL = `wss://${MQTT_HOST}:${MQTT_WS_PORT}/mqtt`;

  const MQTT_USERNAME = "hivemq.webclient.1768060269881";
  const MQTT_PASSWORD = "#BFa@Eeg<f,h86d9D4CA";

  const TOPIC_TLE = "cubesat/tle";
  const TOPIC_IMU = "cubesat/attitude";

  /* ===== Camera presets ===== */
  const INDIA_HOME = { lon: 78.9629, lat: 20.5937, height: 8.0e6 };
  const WORLD_ALT  = 3.2e7;

  /* ===== Ground Station ===== */
  const GROUND_STATION = { name: "ground_station", lat: 13.0037, lon: 80.2041, altM: 12 };
  const INDIA_BBOX = { latMin: 6.0, latMax: 37.5, lonMin: 68.0, lonMax: 98.0 };

  // Orbit sampling horizon
  const SAMPLE_PAST_SEC   = 70 * 60;
  const SAMPLE_FUTURE_SEC = 70 * 60;

  // Append samples ahead
  const APPEND_AHEAD_SEC  = 240;
  const APPEND_EVERY_MS   = 250;

  // Coverage ring
  const MIN_ELEV_DEG = 10;
  const COVER_SMOOTH = 0.14;
  const COVER_POINTS = 96;
  const COVER_MAX_M  = 6500000;

  // IMU
  const imu = { roll: 0, pitch: 0, yaw: 0 };
  const IMU_SIGN = { roll: +1, pitch: +1, yaw: +1 };
  let imuZero = null;

  // 2D behavior
  let follow2D = false;
  const FOLLOW2D_HEIGHT_M = 1.8e6;

  const missionStartMs = performance.now();

  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
  function normLon(lon){
    let L = lon;
    while (L > 180) L -= 360;
    while (L < -180) L += 360;
    return L;
  }

  const DPR = clamp(window.devicePixelRatio || 1, 1, 2);
  const RES_SCALE = clamp(DPR * 1.2, 1, 2);

  /* ===================== DOM ===================== */
  const el = (id) => document.getElementById(id);
  const stEl = el("st"), utcEl = el("utc"), metEl = el("met"),
        latEl = el("lat"), lonEl = el("lon"),
        altEl = el("alt"), spdEl = el("spd"), mqEl = el("mq"),
        tleAgeEl = el("tleAge"), tleBox = el("tleBox");

  const btnSat = el("btnSat"), btnWorld = el("btnWorld"), btn2d = el("btn2d");
  const row2dOpts = el("row2dOpts");
  const btn2dFollow = el("btn2dFollow");
  const btn2dZoom   = el("btn2dZoom");

  const hud = el("hud");
  const miniDiv = el("miniSatView");

  const liveDot = el("liveDot");
  const liveTxt = el("liveTxt");

  const modal = el("modal");
  const modalBody = el("modalBody");
  const modalClose = el("modalClose");

  function setStatus(s){ stEl.textContent = s; }
  function nowUTCString(){ return new Date().toISOString().replace("T"," ").replace("Z"," UTC"); }

  function formatMET(ms){
    const s = Math.max(0, Math.floor(ms/1000));
    const hh = String(Math.floor(s/3600)).padStart(2,"0");
    const mm = String(Math.floor((s%3600)/60)).padStart(2,"0");
    const ss = String(s%60).padStart(2,"0");
    return `${hh}:${mm}:${ss}`;
  }

  function setLive(mode){
    liveTxt.textContent = mode;
    if (mode === "LIVE") {
      liveDot.style.background = "rgba(0,255,255,0.95)";
      liveDot.style.boxShadow = "0 0 14px rgba(0,255,255,0.55)";
    } else if (mode === "RECONNECT") {
      liveDot.style.background = "rgba(255,210,0,0.95)";
      liveDot.style.boxShadow = "0 0 14px rgba(255,210,0,0.55)";
    } else if (mode === "OFFLINE") {
      liveDot.style.background = "rgba(255,80,80,0.95)";
      liveDot.style.boxShadow = "0 0 14px rgba(255,80,80,0.55)";
    } else {
      liveDot.style.background = "rgba(180,180,180,0.95)";
      liveDot.style.boxShadow = "0 0 14px rgba(180,180,180,0.35)";
    }
  }
  setLive("BOOT");

  function setActive(btn){
    [btnSat, btnWorld, btn2d].forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
  }
  function set2dActive(btn){
    [btn2dFollow, btn2dZoom].forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
  }

  function showMiniView(show){
    miniDiv.style.display = show ? "block" : "none";
    layoutMini();
  }
  function layoutMini(){
    const r = hud.getBoundingClientRect();
    miniDiv.style.top = (Math.round(r.bottom) + 12) + "px";
  }
  window.addEventListener("resize", layoutMini);

  function openModalHtml(html){
    modalBody.innerHTML = html;
    modal.style.display = "flex";
  }
  function closeModal(){ modal.style.display = "none"; }
  modalClose.onclick = closeModal;
  modal.onclick = (e)=>{ if (e.target === modal) closeModal(); };

  /* ===================== CESIUM VIEWER ===================== */
  const viewer = new Cesium.Viewer("cesiumContainer", {
    animation: false,
    timeline: false,
    baseLayerPicker: false,
    sceneModePicker: false,
    geocoder: false,
    navigationHelpButton: false,
    fullscreenButton: false,
    infoBox: false,
    selectionIndicator: false,
    homeButton: true,
    requestRenderMode: false
  });

  viewer.scene.backgroundColor = Cesium.Color.BLACK;
  viewer.scene.skyBox = undefined;
  viewer.scene.skyAtmosphere.show = false;

  viewer.resolutionScale = RES_SCALE;
  viewer.scene.postProcessStages.fxaa.enabled = !!PERF.FXAA;

  viewer.scene.globe.maximumScreenSpaceError = PERF.MAX_SSE;
  viewer.scene.globe.tileCacheSize = PERF.TILE_CACHE;
  viewer.scene.globe.enableLighting = !!PERF.ENABLE_LIGHTING;
  viewer.scene.globe.depthTestAgainstTerrain = !!PERF.DEPTH_TEST_TERRAIN;

  if (PERF.ENABLE_WORLD_TERRAIN) {
    try {
      if (Cesium.createWorldTerrainAsync) {
        viewer.terrainProvider = await Cesium.createWorldTerrainAsync();
      }
    } catch {}
  }

  viewer.camera.setView({
    destination: Cesium.Cartesian3.fromDegrees(INDIA_HOME.lon, INDIA_HOME.lat, INDIA_HOME.height)
  });

  viewer.clock.clockRange = Cesium.ClockRange.UNBOUNDED;
  viewer.clock.multiplier = 1;
  viewer.clock.shouldAnimate = true;
  viewer.clock.clockStep = Cesium.ClockStep.SYSTEM_CLOCK_MULTIPLIER;

  /* ===================== MINI VIEWER ===================== */
  const miniViewer = new Cesium.Viewer("miniSatView", {
    animation: false,
    timeline: false,
    baseLayerPicker: false,
    sceneModePicker: false,
    geocoder: false,
    navigationHelpButton: false,
    fullscreenButton: false,
    infoBox: false,
    selectionIndicator: false,
    homeButton: false,
    requestRenderMode: false
  });

  miniViewer.scene.backgroundColor = Cesium.Color.BLACK;
  miniViewer.scene.skyBox = undefined;
  miniViewer.scene.skyAtmosphere.show = false;

  miniViewer.resolutionScale = RES_SCALE;
  miniViewer.scene.postProcessStages.fxaa.enabled = !!PERF.FXAA;
  miniViewer.scene.globe.maximumScreenSpaceError = PERF.MAX_SSE;
  miniViewer.scene.globe.tileCacheSize = Math.floor(PERF.TILE_CACHE * 0.6);
  miniViewer.scene.globe.enableLighting = !!PERF.ENABLE_LIGHTING;
  miniViewer.scene.globe.depthTestAgainstTerrain = !!PERF.DEPTH_TEST_TERRAIN;

  miniViewer.clock.clockStep = Cesium.ClockStep.SYSTEM_CLOCK_MULTIPLIER;
  miniViewer.clock.multiplier = 1;
  miniViewer.clock.shouldAnimate = true;

  /* ===================== GROUND STATION ===================== */
  const gsPos = new Cesium.CallbackProperty(() => {
    return Cesium.Cartesian3.fromDegrees(GROUND_STATION.lon, GROUND_STATION.lat, 0);
  }, false);

  const gsHeightRef = new Cesium.CallbackProperty(() => {
    return (viewer.scene.mode === Cesium.SceneMode.SCENE3D)
      ? Cesium.HeightReference.CLAMP_TO_GROUND
      : Cesium.HeightReference.NONE;
  }, false);

  viewer.entities.add({
    name: GROUND_STATION.name,
    position: gsPos,
    billboard: {
      image: "data:image/svg+xml;charset=utf-8," + encodeURIComponent(`
        <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64">
          <circle cx="32" cy="32" r="10" fill="rgba(0,255,255,0.95)"/>
          <circle cx="32" cy="32" r="18" fill="none" stroke="rgba(0,255,255,0.55)" stroke-width="3"/>
          <circle cx="32" cy="32" r="26" fill="none" stroke="rgba(0,255,255,0.22)" stroke-width="3"/>
        </svg>
      `),
      width: 28,
      height: 28,
      verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
      horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
      heightReference: gsHeightRef,
      disableDepthTestDistance: 200000.0
    },
    label: {
      text: GROUND_STATION.name,
      font: "13px system-ui",
      fillColor: Cesium.Color.CYAN,
      outlineColor: Cesium.Color.BLACK,
      outlineWidth: 3,
      style: Cesium.LabelStyle.FILL_AND_OUTLINE,
      horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
      verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
      heightReference: gsHeightRef,
      pixelOffset: new Cesium.Cartesian2(0, -34),
      disableDepthTestDistance: 200000.0
    }
  });

  /* ===================== ORBIT (SGP4) ===================== */
  let satName = "CubeSat";
  let satrec = null;
  let tleReceivedAt = null;

  function parseTLEMessage(msg) {
    try {
      const j = JSON.parse(msg);
      if (j && j.line1 && j.line2) return { name: j.name || "SAT", l1: j.line1.trim(), l2: j.line2.trim() };
    } catch {}
    const lines = String(msg).split("\n").map(s=>s.trim()).filter(Boolean);
    if (lines.length >= 3) return { name: lines[0], l1: lines[1], l2: lines[2] };
    if (lines.length >= 2) return { name: "SAT", l1: lines[0], l2: lines[1] };
    return null;
  }

  function propagateLLA(date) {
    if (!satrec) return null;
    const pv = satellite.propagate(satrec, date);
    if (!pv || !pv.position || !pv.velocity) return null;

    const gmst = satellite.gstime(date);
    const gd = satellite.eciToGeodetic(pv.position, gmst);

    const lat = Cesium.Math.toDegrees(gd.latitude);
    const lon = Cesium.Math.toDegrees(gd.longitude);
    const altKm = gd.height;

    const v = pv.velocity;
    const speedKmS = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);

    return { lat, lon, altKm, speedKmS };
  }

  function llaToCartesian(lat, lon, altKm){
    return Cesium.Cartesian3.fromDegrees(lon, lat, altKm * 1000);
  }

  function coverageRadiusMeters(altMeters, minElevDeg) {
    const R = 6378137.0;
    const h = Math.max(0, altMeters);
    const e = Cesium.Math.toRadians(minElevDeg);
    const term = (R / (R + h)) * Math.cos(e);
    const psi = Math.acos(Math.min(1, Math.max(-1, term))) - e;
    return Math.max(0, R * psi);
  }

  /* ===================== SAMPLED POSITION ===================== */
  let sampledPos = new Cesium.SampledPositionProperty();
  sampledPos.setInterpolationOptions({
    interpolationDegree: 2,
    interpolationAlgorithm: Cesium.HermitePolynomialApproximation
  });

  let lastSampledTo = null;
  let satEntity = null;
  let miniSatEntity = null;

  function clearSamples(){
    sampledPos = new Cesium.SampledPositionProperty();
    sampledPos.setInterpolationOptions({
      interpolationDegree: 2,
      interpolationAlgorithm: Cesium.HermitePolynomialApproximation
    });
    if (satEntity) satEntity.position = sampledPos;
    if (miniSatEntity) miniSatEntity.position = sampledPos;
  }

  function syncClocksTo(centerDate){
    const center = Cesium.JulianDate.fromDate(centerDate);
    viewer.clock.currentTime = center.clone();
    viewer.clock.startTime   = Cesium.JulianDate.addSeconds(center, -SAMPLE_PAST_SEC, new Cesium.JulianDate());
    viewer.clock.stopTime    = Cesium.JulianDate.addSeconds(center,  SAMPLE_FUTURE_SEC, new Cesium.JulianDate());
    viewer.clock.clockRange  = Cesium.ClockRange.UNBOUNDED;
    viewer.clock.shouldAnimate = true;

    miniViewer.clock.currentTime = center.clone();
    miniViewer.clock.startTime   = viewer.clock.startTime.clone();
    miniViewer.clock.stopTime    = viewer.clock.stopTime.clone();
    miniViewer.clock.clockRange  = Cesium.ClockRange.UNBOUNDED;
    miniViewer.clock.shouldAnimate = true;
  }

  function seedSamples(centerDate){
    clearSamples();
    lastSampledTo = null;
    syncClocksTo(centerDate);

    const center = Cesium.JulianDate.fromDate(centerDate);
    for (let t = -SAMPLE_PAST_SEC; t <= SAMPLE_FUTURE_SEC; t += PERF.SAMPLE_STEP_SEC) {
      const d = new Date(centerDate.getTime() + t*1000);
      const s = propagateLLA(d);
      if (!s) continue;
      const jt = Cesium.JulianDate.addSeconds(center, t, new Cesium.JulianDate());
      sampledPos.addSample(jt, llaToCartesian(s.lat, s.lon, s.altKm));
      lastSampledTo = jt;
    }
  }

  function appendSamplesAhead(){
    if (!satrec || !lastSampledTo) return;
    const now = viewer.clock.currentTime;
    const target = Cesium.JulianDate.addSeconds(now, APPEND_AHEAD_SEC, new Cesium.JulianDate());

    while (Cesium.JulianDate.lessThan(lastSampledTo, target)) {
      const next = Cesium.JulianDate.addSeconds(lastSampledTo, PERF.SAMPLE_STEP_SEC, new Cesium.JulianDate());
      const d = Cesium.JulianDate.toDate(next);
      const s = propagateLLA(d);
      if (s) sampledPos.addSample(next, llaToCartesian(s.lat, s.lon, s.altKm));
      lastSampledTo = next;
    }
  }

  /* ===================== STATE CACHE (NO LAG) ===================== */
  let state = { lat: 0, lon: 0, altKm: 0, speedKmS: 0 };
  let lastStateMs = 0;
  const STATE_DT_MS = 1000 / PERF.STATE_HZ;

  function updateStateCache(){
    if (!satrec) return;
    const nowMs = performance.now();
    if (nowMs - lastStateMs < STATE_DT_MS) return;
    lastStateMs = nowMs;

    const nowDate = Cesium.JulianDate.toDate(viewer.clock.currentTime);
    const s = propagateLLA(nowDate);
    if (s) state = s;
  }

  /* ===================== IMU -> Orientation ===================== */
  function getImuHPR(){
    const z = imuZero || { roll: 0, pitch: 0, yaw: 0 };
    const roll  = (imu.roll  - z.roll)  * IMU_SIGN.roll;
    const pitch = (imu.pitch - z.pitch) * IMU_SIGN.pitch;
    const yaw   = (imu.yaw   - z.yaw)   * IMU_SIGN.yaw;

    return {
      h: Cesium.Math.toRadians(yaw),
      p: Cesium.Math.toRadians(pitch),
      r: Cesium.Math.toRadians(roll)
    };
  }

  const imuOrientation = new Cesium.CallbackProperty((time) => {
    const pos = sampledPos.getValue(time, new Cesium.Cartesian3());
    if (!pos) return Cesium.Quaternion.IDENTITY;
    const { h, p, r } = getImuHPR();
    const hpr = new Cesium.HeadingPitchRoll(h, p, r);
    return Cesium.Transforms.headingPitchRollQuaternion(pos, hpr);
  }, false);

  /* ===================== SAT ENTITY (GLB + fallback point) ===================== */
  satEntity = viewer.entities.add({
    name: "CubeSat",
    position: sampledPos,
    orientation: imuOrientation,
    model: {
      uri: MODEL_URI,
      minimumPixelSize: 70,
      maximumScale: 80000,
      shadows: Cesium.ShadowMode.DISABLED
    },
    point: {
      pixelSize: 8,
      color: Cesium.Color.CYAN,
      outlineColor: Cesium.Color.BLACK,
      outlineWidth: 2
    },
    label: {
      text: new Cesium.CallbackProperty(() => satName, false),
      font: "14px system-ui",
      fillColor: Cesium.Color.WHITE,
      outlineColor: Cesium.Color.BLACK,
      outlineWidth: 3,
      style: Cesium.LabelStyle.FILL_AND_OUTLINE,
      pixelOffset: new Cesium.Cartesian2(14, -14),
      distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 5.0e8)
    },
    path: {
      show: true,
      leadTime: SAMPLE_FUTURE_SEC,
      trailTime: SAMPLE_PAST_SEC,
      width: 2,
      resolution: 1,
      material: new Cesium.PolylineGlowMaterialProperty({
        glowPower: 0.18,
        color: Cesium.Color.CYAN.withAlpha(0.9)
      })
    }
  });

  miniSatEntity = miniViewer.entities.add({
    position: sampledPos,
    orientation: imuOrientation,
    model: {
      uri: MODEL_URI,
      minimumPixelSize: 90,
      maximumScale: 120000,
      shadows: Cesium.ShadowMode.DISABLED
    },
    point: { pixelSize: 8, color: Cesium.Color.CYAN }
  });
  miniViewer.trackedEntity = miniSatEntity;

  /* ===================== COVERAGE RING (THROTTLED) ===================== */
  let covRadiusSmoothM = 0;
  let cachedRing = [];
  let lastCoverMs = 0;
  const COVER_DT_MS = 1000 / PERF.COVER_HZ;

  function destinationLatLon(latDeg, lonDeg, bearingDeg, distanceM){
    const R = 6378137.0;
    const φ1 = Cesium.Math.toRadians(latDeg);
    const λ1 = Cesium.Math.toRadians(lonDeg);
    const θ  = Cesium.Math.toRadians(bearingDeg);
    const δ  = distanceM / R;

    const sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1);
    const sinδ  = Math.sin(δ),  cosδ  = Math.cos(δ);

    const sinφ2 = sinφ1*cosδ + cosφ1*sinδ*Math.cos(θ);
    const φ2 = Math.asin(Math.min(1, Math.max(-1, sinφ2)));

    const y = Math.sin(θ) * sinδ * cosφ1;
    const x = cosδ - sinφ1 * Math.sin(φ2);
    const λ2 = λ1 + Math.atan2(y, x);

    let lat2 = Cesium.Math.toDegrees(φ2);
    let lon2 = Cesium.Math.toDegrees(λ2);

    lon2 = normLon(lon2);
    return { lat: lat2, lon: lon2 };
  }

  function updateCoverageCache(){
    if (!satrec) { cachedRing = []; return; }

    const nowMs = performance.now();
    if (nowMs - lastCoverMs < COVER_DT_MS) return;
    lastCoverMs = nowMs;

    const centerLat = state.lat;
    const centerLon = normLon(state.lon);

    const rTarget = clamp(coverageRadiusMeters(state.altKm * 1000, MIN_ELEV_DEG), 0, COVER_MAX_M);
    covRadiusSmoothM += (rTarget - covRadiusSmoothM) * COVER_SMOOTH;

    const pts = [];
    const step = 360 / COVER_POINTS;

    let prevLon = null;
    let wrapOffset = 0;

    for (let i = 0; i <= COVER_POINTS; i++) {
      const brg = i * step;
      const p = destinationLatLon(centerLat, centerLon, brg, covRadiusSmoothM);

      let lon = p.lon;
      if (prevLon != null) {
        const d = lon - prevLon;
        if (d > 180) wrapOffset -= 360;
        else if (d < -180) wrapOffset += 360;
      }
      prevLon = lon;

      pts.push(Cesium.Cartesian3.fromDegrees(lon + wrapOffset, p.lat, 5.0));
    }
    cachedRing = pts;
  }

  viewer.entities.add({
    polyline: {
      positions: new Cesium.CallbackProperty(() => cachedRing, false),
      width: 2.0,
      clampToGround: false,
      arcType: Cesium.ArcType.GEODESIC,
      material: new Cesium.PolylineGlowMaterialProperty({
        glowPower: 0.12,
        color: Cesium.Color.YELLOW.withAlpha(0.75)
      })
    }
  });

  /* ===================== HUD UPDATE ===================== */
  function updateHud(){
    utcEl.textContent = nowUTCString();
    metEl.textContent = formatMET(performance.now() - missionStartMs);

    updateStateCache();
    updateCoverageCache();

    if (!satrec) {
      latEl.textContent = lonEl.textContent = altEl.textContent = spdEl.textContent = "—";
      tleAgeEl.textContent = "—";
      return;
    }

    latEl.textContent = state.lat.toFixed(4) + "°";
    lonEl.textContent = normLon(state.lon).toFixed(4) + "°";
    altEl.textContent = state.altKm.toFixed(2) + " km";
    spdEl.textContent = (state.speedKmS * 1000).toFixed(2) + " m/s";

    if (tleReceivedAt) {
      tleAgeEl.textContent = Math.floor((Date.now() - tleReceivedAt.getTime())/1000) + " s";
    }

    if (viewer.scene.mode === Cesium.SceneMode.SCENE2D && follow2D) {
      viewer.camera.setView({
        destination: Cesium.Cartesian3.fromDegrees(state.lon, state.lat, FOLLOW2D_HEIGHT_M)
      });
    }

    layoutMini();
  }

  viewer.scene.postRender.addEventListener(updateHud);
  setInterval(appendSamplesAhead, APPEND_EVERY_MS);

  /* ===================== POV ===================== */
  function setSatPOV(){
    setActive(btnSat);
    row2dOpts.style.display = "none";
    viewer.scene.morphTo3D(0.6);
    viewer.trackedEntity = satEntity;
    showMiniView(false);
    setStatus("Sat POV ✅");
  }

  function setWorldPOV(){
    setActive(btnWorld);
    row2dOpts.style.display = "none";
    viewer.scene.morphTo3D(0.6);
    viewer.trackedEntity = satEntity;
    showMiniView(true);

    viewer.zoomTo(satEntity, new Cesium.HeadingPitchRange(
      Cesium.Math.toRadians(20),
      Cesium.Math.toRadians(-35),
      WORLD_ALT
    ));

    setStatus("World POV ✅");
  }

  function fitWhole2DMap(){
    viewer.camera.flyTo({ destination: Cesium.Rectangle.MAX_VALUE, duration: 0.9 });
  }

  function set2DPOV(){
    setActive(btn2d);
    viewer.trackedEntity = undefined;
    viewer.scene.morphTo2D(0.8);
    row2dOpts.style.display = "flex";

    follow2D = false;
    set2dActive(btn2dZoom);
    showMiniView(true);
    setStatus("2D Zoom Out ✅");

    setTimeout(fitWhole2DMap, 250);
  }

  btn2dFollow.onclick = () => {
    follow2D = true;
    set2dActive(btn2dFollow);
    showMiniView(false);
    setStatus("2D Trace ✅");
  };

  btn2dZoom.onclick = () => {
    follow2D = false;
    set2dActive(btn2dZoom);
    showMiniView(true);
    setStatus("2D Zoom Out ✅");
    fitWhole2DMap();
  };

  btnSat.onclick = setSatPOV;
  btnWorld.onclick = setWorldPOV;
  btn2d.onclick = set2DPOV;

  setSatPOV();
  layoutMini();

  /* ===================== PASS PLANNER ===================== */
  function fmtTime(d){ return d.toISOString().replace("T"," ").replace("Z"," UTC"); }

  function isOverIndia(lat, lon){
    const L = normLon(lon);
    return (
      lat >= INDIA_BBOX.latMin && lat <= INDIA_BBOX.latMax &&
      L   >= INDIA_BBOX.lonMin && L   <= INDIA_BBOX.lonMax
    );
  }

  function lookElevationDeg(date, obsLat, obsLon, obsAltM){
    if (!satrec) return null;
    const pv = satellite.propagate(satrec, date);
    if (!pv || !pv.position) return null;

    const gmst = satellite.gstime(date);
    const positionEcf = satellite.eciToEcf(pv.position, gmst);

    const observerGd = {
      latitude: Cesium.Math.toRadians(obsLat),
      longitude: Cesium.Math.toRadians(obsLon),
      height: obsAltM / 1000.0
    };

    const lookAngles = satellite.ecfToLookAngles(observerGd, positionEcf);
    return Cesium.Math.toDegrees(lookAngles.elevation);
  }

  function findNextGroundPass(startDate, horizonHours = 24, stepSec = 10, minElevDeg = 10){
    if (!satrec) return null;
    const end = new Date(startDate.getTime() + horizonHours * 3600 * 1000);

    let inPass = false;
    let aos = null, los = null;
    let maxEl = -999, tMax = null;

    for (let t = new Date(startDate); t <= end; t = new Date(t.getTime() + stepSec*1000)) {
      const elv = lookElevationDeg(t, GROUND_STATION.lat, GROUND_STATION.lon, GROUND_STATION.altM);
      if (elv == null) continue;

      const above = elv >= minElevDeg;

      if (!inPass && above) {
        inPass = true;
        aos = new Date(t);
        maxEl = elv; tMax = new Date(t);
      }

      if (inPass) {
        if (elv > maxEl) { maxEl = elv; tMax = new Date(t); }
        if (!above) {
          los = new Date(t);
          return { aos, los, maxEl, tMax };
        }
      }
    }
    return null;
  }

  function findNextIndiaOverflight(startDate, horizonHours = 24, stepSec = 20){
    if (!satrec) return null;

    const end = new Date(startDate.getTime() + horizonHours * 3600 * 1000);
    let inside = false;
    let enter = null, exit = null;

    for (let t = new Date(startDate); t <= end; t = new Date(t.getTime() + stepSec*1000)) {
      const s = propagateLLA(t);
      if (!s) continue;

      const isIn = isOverIndia(s.lat, s.lon);

      if (!inside && isIn) { inside = true; enter = new Date(t); }
      if (inside && !isIn) { exit = new Date(t); return { enter, exit }; }
    }
    return null;
  }

  function passRow(label, value){
    const safe = (s)=>String(s).replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m]));
    return `
      <div class="passRow">
        <div class="passK">${safe(label)}</div>
        <div class="passV">${safe(value)}</div>
      </div>`;
  }

  async function showPassPlanner(){
    if (!satrec) {
      openModalHtml(`
        <div class="passBlock">
          ${passRow("NO T_attachment", "No TLE loaded yet")}
          ${passRow("PUBLISH", TOPIC_TLE)}
        </div>
      `);
      return;
    }

    openModalHtml(`<div class="passBlock">${passRow("STATUS", "Computing next passes…")}</div>`);

    const now = new Date();
    const pass = findNextGroundPass(now, 24, 10, 10);
    const india = findNextIndiaOverflight(now, 24, 20);

    let html = `<div class="passBlock">`;
    html += passRow("NEXT GS PASS (AOS)", pass ? pass.aos.toISOString() : "—");
    html += passRow("LOS", pass ? pass.los.toISOString() : "—");
    if (pass){
      const durSec = Math.max(0, Math.floor((pass.los - pass.aos)/1000));
      const mm = Math.floor(durSec/60), ss = durSec%60;
      html += passRow("DURATION", `${mm}m ${ss}s`);
      html += passRow("MAX ELEVATION", `${pass.maxEl.toFixed(1)}°`);
      html += passRow("MAX ELEV TIME", pass.tMax.toISOString());
    } else {
      html += passRow("DURATION", "—");
      html += passRow("MAX ELEVATION", "—");
      html += passRow("MAX ELEV TIME", "—");
    }
    html += `</div>`;

    html += `<div class="passSep"></div>`;

    html += `<div class="passBlock">`;
    html += passRow("NEXT INDIA PASS (AOS)", india ? india.enter.toISOString() : "—");
    html += passRow("LOS", india ? india.exit.toISOString() : "—");
    if (india){
      const durSec = Math.max(0, Math.floor((india.exit - india.enter)/1000));
      const mm = Math.floor(durSec/60), ss = durSec%60;
      html += passRow("DURATION", `${mm}m ${ss}s`);
    } else {
      html += passRow("DURATION", "—");
    }
    html += `</div>`;

    openModalHtml(html);
  }

  viewer.homeButton.viewModel.command.beforeExecute.addEventListener((e) => {
    e.cancel = true;
    viewer.camera.flyTo({
      destination: Cesium.Cartesian3.fromDegrees(GROUND_STATION.lon, GROUND_STATION.lat, 2.2e6),
      duration: 0.9
    });
    setTimeout(showPassPlanner, 250);
  });

  /* ===================== APPLY TLE ===================== */
  function setTLE(name, l1, l2){
    satName = name || "SAT";
    tleReceivedAt = new Date();
    satrec = satellite.twoline2satrec(l1, l2);

    tleBox.textContent = `${satName}\n${l1}\n${l2}`;
    setStatus("TLE Loaded");

    seedSamples(new Date());
    updateStateCache();

    if (btnWorld.classList.contains("active")) setWorldPOV();
    else if (btn2d.classList.contains("active")) set2DPOV();
    else setSatPOV();
  }

  /* ===================== MQTT ===================== */
  setStatus("Connecting Data Ing…");
  mqEl.textContent = "Connecting…";
  setLive("RECONNECT");

  console.log("[MQTT] connecting:", MQTT_WSS_URL);

  const mqttClient = mqtt.connect(MQTT_WSS_URL, {
    clientId: "cubesat-tracker-" + Math.random().toString(16).slice(2),
    username: MQTT_USERNAME,
    password: MQTT_PASSWORD,
    protocol: "wss",
    keepalive: 30,
    reconnectPeriod: 2000,
    connectTimeout: 20000,
    clean: true,
    resubscribe: true
  });

  mqttClient.on("connect", () => {
    mqEl.textContent = "LIVE";
    setStatus("TLE " + (satrec ? "Loaded" : "Waiting"));
    setLive("LIVE");

    mqttClient.subscribe(TOPIC_TLE, { qos: 1 }, (err) => { if (err) setStatus("Subscribe TLE error ❌"); });
    mqttClient.subscribe(TOPIC_IMU, { qos: 0 }, (err) => { if (err) setStatus("Subscribe IMU error ❌"); });
  });

  mqttClient.on("message", (topic, payload) => {
    const msg = payload.toString();

    if (topic === TOPIC_TLE) {
      const tle = parseTLEMessage(msg);
      if (!tle) { setStatus("Bad TLE format ❌"); return; }
      setTLE(tle.name, tle.l1, tle.l2);
      return;
    }

    if (topic === TOPIC_IMU) {
      try {
        const data = JSON.parse(msg);
        const r = Number(data.roll  ?? data.Roll  ?? data.roll_deg  ?? data.rollDeg);
        const p = Number(data.pitch ?? data.Pitch ?? data.pitch_deg ?? data.pitchDeg);
        const y = Number(data.yaw   ?? data.Yaw   ?? data.yaw_deg   ?? data.yawDeg);

        if (!Number.isNaN(r)) imu.roll = r;
        if (!Number.isNaN(p)) imu.pitch = p;
        if (!Number.isNaN(y)) imu.yaw = y;

        if (!imuZero) imuZero = { roll: imu.roll, pitch: imu.pitch, yaw: imu.yaw };
      } catch {}
    }
  });

  mqttClient.on("reconnect", () => {
    mqEl.textContent = "RECONNECT";
    setStatus("Data Ing reconnecting…");
    setLive("RECONNECT");
  });

  mqttClient.on("close", () => {
    mqEl.textContent = "OFFLINE";
    setStatus("Data Ing disconnected");
    setLive("OFFLINE");
  });

  mqttClient.on("offline", () => {
    mqEl.textContent = "OFFLINE";
    setStatus("Data Ing offline");
    setLive("OFFLINE");
  });

  mqttClient.on("error", (e) => {
    console.log("[MQTT] ERROR", e);
    mqEl.textContent = "ERROR";
    setStatus("Data Ing error ❌");
    setLive("OFFLINE");
  });
})();
</script>
</body>
</html>
