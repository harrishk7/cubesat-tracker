<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CubeSat Tracker</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- Cesium -->
  <link href="https://unpkg.com/cesium/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />
  <script src="https://unpkg.com/cesium/Build/Cesium/Cesium.js"></script>

  <!-- SGP4 -->
  <script src="https://unpkg.com/satellite.js/dist/satellite.min.js"></script>

  <!-- MQTT (WebSocket) -->
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>

  <style>
    html, body, #cesiumContainer {
      width:100%; height:100%;
      margin:0; padding:0;
      overflow:hidden;
      background:#000;
    }

    /* HUD */
    #hud{
      position:absolute;
      left:12px; top:12px;
      z-index:30;
      width: 380px;
      max-height: calc(100vh - 24px);
      overflow:auto;
      padding:12px;
      border-radius:14px;
      background: rgba(0,0,0,0.55);
      border:1px solid rgba(255,255,255,0.14);
      color:#fff;
      font:12px/1.45 system-ui, sans-serif;
      backdrop-filter: blur(8px);
    }

    #livePill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      font: 11px system-ui, sans-serif;
      user-select:none;
      white-space:nowrap;
    }
    #liveDot{
      width:8px; height:8px;
      border-radius:999px;
      background: rgba(180,180,180,0.95);
      box-shadow: 0 0 14px rgba(180,180,180,0.35);
    }
    #liveTxt{ letter-spacing: 0.4px; opacity: 0.92; }

    #miniSatView{
      position:absolute;
      left:12px;
      top: 320px;
      width:380px;
      height:230px;
      border-radius:14px;
      overflow:hidden;
      border:1px solid rgba(0,255,255,0.35);
      background:#000;
      z-index:20;
      box-shadow: 0 0 24px rgba(0,255,255,0.18);
      display:none;
    }

    #hud h3 { margin:0; font-size:13px; }

    .row { display:flex; gap:8px; margin-bottom:10px; }
    button{
      flex:1; cursor:pointer;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      color:#fff;
      font:12px system-ui, sans-serif;
    }
    button.active{
      border-color: rgba(0,255,255,0.6);
      box-shadow: 0 0 0 1px rgba(0,255,255,0.25) inset;
    }

    .kv { display:flex; justify-content:space-between; gap:12px; margin:4px 0; }
    .k { opacity:0.78; }
    .v { font-variant-numeric: tabular-nums; }

    pre{
      margin:10px 0 0;
      padding:8px 10px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      white-space: pre-wrap;
      word-break: break-word;
      font-size: 11px;
      line-height: 1.35;
    }

    #modal{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index:100;
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(6px);
    }
    #modalCard{
      width:min(760px, calc(100vw - 24px));
      border-radius:16px;
      border:1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.78);
      color:#fff;
      padding:14px 14px 12px;
      box-shadow: 0 0 40px rgba(0,0,0,0.6);
      font: 12px/1.45 system-ui, sans-serif;
    }
    #modalTop{
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:center;
      margin-bottom:8px;
    }
    #modalTitle{
      font-size:13px;
      margin:0;
      opacity:0.95;
    }
    #modalClose{
      cursor:pointer;
      padding:6px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      color:#fff;
      font: 12px system-ui, sans-serif;
    }

    .cesium-viewer-bottom { display:none !important; }
  </style>
</head>

<body>
  <div id="cesiumContainer"></div>

  <div id="modal">
    <div id="modalCard">
      <div id="modalTop">
        <h4 id="modalTitle">Ground Station • Pass Planner</h4>
        <button id="modalClose">Close</button>
      </div>
      <pre id="modalBody">Loading…</pre>
    </div>
  </div>

  <div id="hud">
    <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px;">
      <h3>CubeSat Tracker</h3>
      <div id="livePill" title="Streaming status">
        <span id="liveDot"></span>
        <span id="liveTxt">BOOT</span>
      </div>
    </div>

    <div class="row">
      <button id="btnSat" class="active">Sat POV</button>
      <button id="btnWorld">World POV</button>
      <button id="btn2d">2D POV</button>
    </div>

    <div class="row" id="row2dOpts" style="display:none;">
      <button id="btn2dFollow">2D: Trace Sat</button>
      <button id="btn2dZoom" class="active">2D: Zoom Out</button>
    </div>

    <div class="kv"><div class="k">Status</div><div class="v" id="st">Booting…</div></div>
    <div class="kv"><div class="k">UTC</div><div class="v" id="utc">—</div></div>

    <div style="height:8px"></div>
    <div class="kv"><div class="k">Lat</div><div class="v" id="lat">—</div></div>
    <div class="kv"><div class="k">Lon</div><div class="v" id="lon">—</div></div>
    <div class="kv"><div class="k">Alt</div><div class="v" id="alt">—</div></div>
    <div class="kv"><div class="k">Speed</div><div class="v" id="spd">—</div></div>

    <div style="height:8px"></div>
    <div class="kv"><div class="k">MQTT</div><div class="v" id="mq">—</div></div>
    <div class="kv"><div class="k">TLE Age</div><div class="v" id="tleAge">—</div></div>

    <pre id="tleBox">Waiting for TLE…</pre>
    <pre id="imuBox">IMU: waiting…</pre>
  </div>

  <div id="miniSatView"></div>

<script>
(async function () {
  "use strict";

  /* ===================== CONFIG ===================== */
  const MODEL_URI = "./assets/CubeSat.glb";

  /* ===================== PERF (butter smooth) ===================== */
  const PERF = {
    // Update cached orbit state at fixed Hz (NOT every frame)
    STATE_HZ: 25,

    // Update coverage ring slower
    COVER_HZ: 8,

    // Orbit samples: fewer points + smooth interpolation
    SAMPLE_STEP_SEC: 5,

    // Terrain is expensive. Keep OFF for smooth.
    ENABLE_WORLD_TERRAIN: false,
    ENABLE_LIGHTING: true,      // looks nice; if lag → set false
    DEPTH_TEST_TERRAIN: false,

    // Globe tuning
    MAX_SSE: 2.0,
    TILE_CACHE: 600,
    FXAA: true
  };

  /* ===== HiveMQ Cloud (Browser must use WSS) ===== */
  const MQTT_HOST = "4bde42256ac0461d872447cc72b1a99f.s1.eu.hivemq.cloud";
  const MQTT_WS_PORT = 8884;
  const MQTT_WSS_URL = `wss://${MQTT_HOST}:${MQTT_WS_PORT}/mqtt`;

  const MQTT_USERNAME = "hivemq.webclient.1768060269881";
  const MQTT_PASSWORD = "#BFa@Eeg<f,h86d9D4CA";

  const TOPIC_TLE = "cubesat/tle";
  const TOPIC_IMU = "cubesat/attitude";

  /* ===== Camera presets ===== */
  const INDIA_HOME = { lon: 78.9629, lat: 20.5937, height: 8.0e6 };
  const WORLD_ALT  = 3.2e7;

  /* ===== Ground Station ===== */
  const GROUND_STATION = { name: "ground_station", lat: 13.0037, lon: 80.2041, altM: 12 };
  const INDIA_BBOX = { latMin: 6.0, latMax: 37.5, lonMin: 68.0, lonMax: 98.0 };

  // Orbit sampling horizon
  const SAMPLE_PAST_SEC   = 70 * 60;
  const SAMPLE_FUTURE_SEC = 70 * 60;

  // Append samples ahead
  const APPEND_AHEAD_SEC  = 240;
  const APPEND_EVERY_MS   = 250;

  // Coverage ring
  const MIN_ELEV_DEG = 10;
  const COVER_SMOOTH = 0.14;
  const COVER_POINTS = 96;
  const COVER_MAX_M  = 6500000;

  // IMU
  const imu = { roll: 0, pitch: 0, yaw: 0 };
  const IMU_SIGN = { roll: +1, pitch: +1, yaw: +1 };

  // ✅ auto-zero so start = 0,0,0
  let imuZero = null;

  // 2D behavior
  let follow2D = false;
  const FOLLOW2D_HEIGHT_M = 1.8e6;

  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
  function normLon(lon){
    let L = lon;
    while (L > 180) L -= 360;
    while (L < -180) L += 360;
    return L;
  }

  const DPR = clamp(window.devicePixelRatio || 1, 1, 2);
  const RES_SCALE = clamp(DPR * 1.2, 1, 2);

  /* ===================== DOM ===================== */
  const el = (id) => document.getElementById(id);
  const stEl = el("st"), utcEl = el("utc"), latEl = el("lat"), lonEl = el("lon"),
        altEl = el("alt"), spdEl = el("spd"), mqEl = el("mq"),
        tleAgeEl = el("tleAge"), tleBox = el("tleBox"), imuBox = el("imuBox");

  const btnSat = el("btnSat"), btnWorld = el("btnWorld"), btn2d = el("btn2d");
  const row2dOpts = el("row2dOpts");
  const btn2dFollow = el("btn2dFollow");
  const btn2dZoom   = el("btn2dZoom");

  const hud = el("hud");
  const miniDiv = el("miniSatView");

  const liveDot = el("liveDot");
  const liveTxt = el("liveTxt");

  const modal = el("modal");
  const modalBody = el("modalBody");
  const modalClose = el("modalClose");

  function setStatus(s){ stEl.textContent = s; }
  function nowUTCString(){ return new Date().toISOString().replace("T"," ").replace("Z"," UTC"); }

  function setLive(mode){
    liveTxt.textContent = mode;
    if (mode === "LIVE") {
      liveDot.style.background = "rgba(0,255,255,0.95)";
      liveDot.style.boxShadow = "0 0 14px rgba(0,255,255,0.55)";
    } else if (mode === "RECONNECT") {
      liveDot.style.background = "rgba(255,210,0,0.95)";
      liveDot.style.boxShadow = "0 0 14px rgba(255,210,0,0.55)";
    } else if (mode === "OFFLINE") {
      liveDot.style.background = "rgba(255,80,80,0.95)";
      liveDot.style.boxShadow = "0 0 14px rgba(255,80,80,0.55)";
    } else {
      liveDot.style.background = "rgba(180,180,180,0.95)";
      liveDot.style.boxShadow = "0 0 14px rgba(180,180,180,0.35)";
    }
  }
  setLive("BOOT");

  function setActive(btn){
    [btnSat, btnWorld, btn2d].forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
  }
  function set2dActive(btn){
    [btn2dFollow, btn2dZoom].forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
  }

  function showMiniView(show){
    miniDiv.style.display = show ? "block" : "none";
    layoutMini();
  }
  function layoutMini(){
    const r = hud.getBoundingClientRect();
    miniDiv.style.top = (Math.round(r.bottom) + 12) + "px";
  }
  window.addEventListener("resize", layoutMini);

  function openModal(text){
    modalBody.textContent = text;
    modal.style.display = "flex";
  }
  function closeModal(){ modal.style.display = "none"; }
  modalClose.onclick = closeModal;
  modal.onclick = (e)=>{ if (e.target === modal) closeModal(); };

  /* ===================== CESIUM VIEWER ===================== */
  const viewer = new Cesium.Viewer("cesiumContainer", {
    animation: false,
    timeline: false,
    baseLayerPicker: false,
    sceneModePicker: false,
    geocoder: false,
    navigationHelpButton: false,
    fullscreenButton: false,
    infoBox: false,
    selectionIndicator: false,
    homeButton: true,
    requestRenderMode: false
  });

  viewer.scene.backgroundColor = Cesium.Color.BLACK;
  viewer.scene.skyBox = undefined;
  viewer.scene.skyAtmosphere.show = false;

  viewer.resolutionScale = RES_SCALE;
  viewer.scene.postProcessStages.fxaa.enabled = !!PERF.FXAA;

  viewer.scene.globe.maximumScreenSpaceError = PERF.MAX_SSE;
  viewer.scene.globe.tileCacheSize = PERF.TILE_CACHE;
  viewer.scene.globe.enableLighting = !!PERF.ENABLE_LIGHTING;
  viewer.scene.globe.depthTestAgainstTerrain = !!PERF.DEPTH_TEST_TERRAIN;

  if (PERF.ENABLE_WORLD_TERRAIN) {
    try {
      if (Cesium.createWorldTerrainAsync) {
        viewer.terrainProvider = await Cesium.createWorldTerrainAsync();
      }
    } catch {}
  }

  viewer.camera.setView({
    destination: Cesium.Cartesian3.fromDegrees(INDIA_HOME.lon, INDIA_HOME.lat, INDIA_HOME.height)
  });

  viewer.clock.clockRange = Cesium.ClockRange.UNBOUNDED;
  viewer.clock.multiplier = 1;
  viewer.clock.shouldAnimate = true;
  viewer.clock.clockStep = Cesium.ClockStep.SYSTEM_CLOCK_MULTIPLIER;

  /* ===================== MINI VIEWER ===================== */
  const miniViewer = new Cesium.Viewer("miniSatView", {
    animation: false,
    timeline: false,
    baseLayerPicker: false,
    sceneModePicker: false,
    geocoder: false,
    navigationHelpButton: false,
    fullscreenButton: false,
    infoBox: false,
    selectionIndicator: false,
    homeButton: false,
    requestRenderMode: false
  });

  miniViewer.scene.backgroundColor = Cesium.Color.BLACK;
  miniViewer.scene.skyBox = undefined;
  miniViewer.scene.skyAtmosphere.show = false;

  miniViewer.resolutionScale = RES_SCALE;
  miniViewer.scene.postProcessStages.fxaa.enabled = !!PERF.FXAA;
  miniViewer.scene.globe.maximumScreenSpaceError = PERF.MAX_SSE;
  miniViewer.scene.globe.tileCacheSize = Math.floor(PERF.TILE_CACHE * 0.6);
  miniViewer.scene.globe.enableLighting = !!PERF.ENABLE_LIGHTING;
  miniViewer.scene.globe.depthTestAgainstTerrain = !!PERF.DEPTH_TEST_TERRAIN;

  miniViewer.clock.clockStep = Cesium.ClockStep.SYSTEM_CLOCK_MULTIPLIER;
  miniViewer.clock.multiplier = 1;
  miniViewer.clock.shouldAnimate = true;

  /* ===================== GROUND STATION ===================== */
  const gsPos = new Cesium.CallbackProperty(() => {
    return Cesium.Cartesian3.fromDegrees(GROUND_STATION.lon, GROUND_STATION.lat, 0);
  }, false);

  const gsHeightRef = new Cesium.CallbackProperty(() => {
    return (viewer.scene.mode === Cesium.SceneMode.SCENE3D)
      ? Cesium.HeightReference.CLAMP_TO_GROUND
      : Cesium.HeightReference.NONE;
  }, false);

  viewer.entities.add({
    name: GROUND_STATION.name,
    position: gsPos,
    billboard: {
      image: "data:image/svg+xml;charset=utf-8," + encodeURIComponent(`
        <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64">
          <circle cx="32" cy="32" r="10" fill="rgba(0,255,255,0.95)"/>
          <circle cx="32" cy="32" r="18" fill="none" stroke="rgba(0,255,255,0.55)" stroke-width="3"/>
          <circle cx="32" cy="32" r="26" fill="none" stroke="rgba(0,255,255,0.22)" stroke-width="3"/>
        </svg>
      `),
      width: 28,
      height: 28,
      verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
      horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
      heightReference: gsHeightRef,
      disableDepthTestDistance: 200000.0
    },
    label: {
      text: GROUND_STATION.name,
      font: "13px system-ui",
      fillColor: Cesium.Color.CYAN,
      outlineColor: Cesium.Color.BLACK,
      outlineWidth: 3,
      style: Cesium.LabelStyle.FILL_AND_OUTLINE,
      horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
      verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
      heightReference: gsHeightRef,
      pixelOffset: new Cesium.Cartesian2(0, -34),
      disableDepthTestDistance: 200000.0
    }
  });

  /* ===================== ORBIT (SGP4) ===================== */
  let satName = "CubeSat";
  let satrec = null;
  let tleReceivedAt = null;

  function parseTLEMessage(msg) {
    try {
      const j = JSON.parse(msg);
      if (j && j.line1 && j.line2) return { name: j.name || "SAT", l1: j.line1.trim(), l2: j.line2.trim() };
    } catch {}
    const lines = String(msg).split("\n").map(s=>s.trim()).filter(Boolean);
    if (lines.length >= 3) return { name: lines[0], l1: lines[1], l2: lines[2] };
    if (lines.length >= 2) return { name: "SAT", l1: lines[0], l2: lines[1] };
    return null;
  }

  function propagateLLA(date) {
    if (!satrec) return null;
    const pv = satellite.propagate(satrec, date);
    if (!pv || !pv.position || !pv.velocity) return null;

    const gmst = satellite.gstime(date);
    const gd = satellite.eciToGeodetic(pv.position, gmst);

    const lat = Cesium.Math.toDegrees(gd.latitude);
    const lon = Cesium.Math.toDegrees(gd.longitude);
    const altKm = gd.height;

    const v = pv.velocity;
    const speedKmS = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);

    return { lat, lon, altKm, speedKmS };
  }

  function llaToCartesian(lat, lon, altKm){
    return Cesium.Cartesian3.fromDegrees(lon, lat, altKm * 1000);
  }

  function coverageRadiusMeters(altMeters, minElevDeg) {
    const R = 6378137.0;
    const h = Math.max(0, altMeters);
    const e = Cesium.Math.toRadians(minElevDeg);
    const term = (R / (R + h)) * Math.cos(e);
    const psi = Math.acos(Math.min(1, Math.max(-1, term))) - e;
    return Math.max(0, R * psi);
  }

  /* ===================== SAMPLED POSITION ===================== */
  let sampledPos = new Cesium.SampledPositionProperty();
  sampledPos.setInterpolationOptions({
    interpolationDegree: 2,
    interpolationAlgorithm: Cesium.HermitePolynomialApproximation
  });

  let lastSampledTo = null;
  let satEntity = null;
  let miniSatEntity = null;

  function clearSamples(){
    sampledPos = new Cesium.SampledPositionProperty();
    sampledPos.setInterpolationOptions({
      interpolationDegree: 2,
      interpolationAlgorithm: Cesium.HermitePolynomialApproximation
    });
    if (satEntity) satEntity.position = sampledPos;
    if (miniSatEntity) miniSatEntity.position = sampledPos;
  }

  function syncClocksTo(centerDate){
    const center = Cesium.JulianDate.fromDate(centerDate);
    viewer.clock.currentTime = center.clone();
    viewer.clock.startTime   = Cesium.JulianDate.addSeconds(center, -SAMPLE_PAST_SEC, new Cesium.JulianDate());
    viewer.clock.stopTime    = Cesium.JulianDate.addSeconds(center,  SAMPLE_FUTURE_SEC, new Cesium.JulianDate());
    viewer.clock.clockRange  = Cesium.ClockRange.UNBOUNDED;
    viewer.clock.shouldAnimate = true;

    miniViewer.clock.currentTime = center.clone();
    miniViewer.clock.startTime   = viewer.clock.startTime.clone();
    miniViewer.clock.stopTime    = viewer.clock.stopTime.clone();
    miniViewer.clock.clockRange  = Cesium.ClockRange.UNBOUNDED;
    miniViewer.clock.shouldAnimate = true;
  }

  function seedSamples(centerDate){
    clearSamples();
    lastSampledTo = null;
    syncClocksTo(centerDate);

    const center = Cesium.JulianDate.fromDate(centerDate);
    for (let t = -SAMPLE_PAST_SEC; t <= SAMPLE_FUTURE_SEC; t += PERF.SAMPLE_STEP_SEC) {
      const d = new Date(centerDate.getTime() + t*1000);
      const s = propagateLLA(d);
      if (!s) continue;
      const jt = Cesium.JulianDate.addSeconds(center, t, new Cesium.JulianDate());
      sampledPos.addSample(jt, llaToCartesian(s.lat, s.lon, s.altKm));
      lastSampledTo = jt;
    }
  }

  function appendSamplesAhead(){
    if (!satrec || !lastSampledTo) return;
    const now = viewer.clock.currentTime;
    const target = Cesium.JulianDate.addSeconds(now, APPEND_AHEAD_SEC, new Cesium.JulianDate());

    while (Cesium.JulianDate.lessThan(lastSampledTo, target)) {
      const next = Cesium.JulianDate.addSeconds(lastSampledTo, PERF.SAMPLE_STEP_SEC, new Cesium.JulianDate());
      const d = Cesium.JulianDate.toDate(next);
      const s = propagateLLA(d);
      if (s) sampledPos.addSample(next, llaToCartesian(s.lat, s.lon, s.altKm));
      lastSampledTo = next;
    }
  }

  /* ===================== STATE CACHE (NO LAG) ===================== */
  let state = { lat: 0, lon: 0, altKm: 0, speedKmS: 0 };
  let lastStateMs = 0;
  const STATE_DT_MS = 1000 / PERF.STATE_HZ;

  function updateStateCache(){
    if (!satrec) return;
    const nowMs = performance.now();
    if (nowMs - lastStateMs < STATE_DT_MS) return;
    lastStateMs = nowMs;

    const nowDate = Cesium.JulianDate.toDate(viewer.clock.currentTime);
    const s = propagateLLA(nowDate);
    if (s) state = s;
  }

  /* ===================== IMU -> Orientation ===================== */
  function getImuHPR(){
    const z = imuZero || { roll: 0, pitch: 0, yaw: 0 };
    const roll  = (imu.roll  - z.roll)  * IMU_SIGN.roll;
    const pitch = (imu.pitch - z.pitch) * IMU_SIGN.pitch;
    const yaw   = (imu.yaw   - z.yaw)   * IMU_SIGN.yaw;

    return {
      h: Cesium.Math.toRadians(yaw),
      p: Cesium.Math.toRadians(pitch),
      r: Cesium.Math.toRadians(roll)
    };
  }

  const imuOrientation = new Cesium.CallbackProperty((time) => {
    const pos = sampledPos.getValue(time, new Cesium.Cartesian3());
    if (!pos) return Cesium.Quaternion.IDENTITY;
    const { h, p, r } = getImuHPR();
    const hpr = new Cesium.HeadingPitchRoll(h, p, r);
    return Cesium.Transforms.headingPitchRollQuaternion(pos, hpr);
  }, false);

  /* ===================== SAT ENTITY (GLB + fallback point) ===================== */
  satEntity = viewer.entities.add({
    name: "CubeSat",
    position: sampledPos,
    orientation: imuOrientation,
    model: {
      uri: MODEL_URI,
      minimumPixelSize: 70,
      maximumScale: 80000,
      shadows: Cesium.ShadowMode.DISABLED
    },
    point: { // fallback if GLB fails
      pixelSize: 8,
      color: Cesium.Color.CYAN,
      outlineColor: Cesium.Color.BLACK,
      outlineWidth: 2
    },
    label: {
      text: new Cesium.CallbackProperty(() => satName, false),
      font: "14px system-ui",
      fillColor: Cesium.Color.WHITE,
      outlineColor: Cesium.Color.BLACK,
      outlineWidth: 3,
      style: Cesium.LabelStyle.FILL_AND_OUTLINE,
      pixelOffset: new Cesium.Cartesian2(14, -14),
      distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 5.0e8)
    },
    path: {
      show: true,
      leadTime: SAMPLE_FUTURE_SEC,
      trailTime: SAMPLE_PAST_SEC,
      width: 2,
      resolution: 1,
      material: new Cesium.PolylineGlowMaterialProperty({
        glowPower: 0.18,
        color: Cesium.Color.CYAN.withAlpha(0.9)
      })
    }
  });

  miniSatEntity = miniViewer.entities.add({
    position: sampledPos,
    orientation: imuOrientation,
    model: {
      uri: MODEL_URI,
      minimumPixelSize: 90,
      maximumScale: 120000,
      shadows: Cesium.ShadowMode.DISABLED
    },
    point: { pixelSize: 8, color: Cesium.Color.CYAN }
  });
  miniViewer.trackedEntity = miniSatEntity;

  /* ===================== COVERAGE RING (THROTTLED) ===================== */
  let covRadiusSmoothM = 0;
  let cachedRing = [];
  let lastCoverMs = 0;
  const COVER_DT_MS = 1000 / PERF.COVER_HZ;

  function destinationLatLon(latDeg, lonDeg, bearingDeg, distanceM){
    const R = 6378137.0;
    const φ1 = Cesium.Math.toRadians(latDeg);
    const λ1 = Cesium.Math.toRadians(lonDeg);
    const θ  = Cesium.Math.toRadians(bearingDeg);
    const δ  = distanceM / R;

    const sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1);
    const sinδ  = Math.sin(δ),  cosδ  = Math.cos(δ);

    const sinφ2 = sinφ1*cosδ + cosφ1*sinδ*Math.cos(θ);
    const φ2 = Math.asin(Math.min(1, Math.max(-1, sinφ2)));

    const y = Math.sin(θ) * sinδ * cosφ1;
    const x = cosδ - sinφ1 * Math.sin(φ2);
    const λ2 = λ1 + Math.atan2(y, x);

    let lat2 = Cesium.Math.toDegrees(φ2);
    let lon2 = Cesium.Math.toDegrees(λ2);

    lon2 = normLon(lon2);
    return { lat: lat2, lon: lon2 };
  }

  function updateCoverageCache(){
    if (!satrec) { cachedRing = []; return; }

    const nowMs = performance.now();
    if (nowMs - lastCoverMs < COVER_DT_MS) return;
    lastCoverMs = nowMs;

    const centerLat = state.lat;
    const centerLon = normLon(state.lon);

    const rTarget = clamp(coverageRadiusMeters(state.altKm * 1000, MIN_ELEV_DEG), 0, COVER_MAX_M);
    covRadiusSmoothM += (rTarget - covRadiusSmoothM) * COVER_SMOOTH;

    const pts = [];
    const step = 360 / COVER_POINTS;

    let prevLon = null;
    let wrapOffset = 0;

    for (let i = 0; i <= COVER_POINTS; i++) {
      const brg = i * step;
      const p = destinationLatLon(centerLat, centerLon, brg, covRadiusSmoothM);

      let lon = p.lon;
      if (prevLon != null) {
        const d = lon - prevLon;
        if (d > 180) wrapOffset -= 360;
        else if (d < -180) wrapOffset += 360;
      }
      prevLon = lon;

      pts.push(Cesium.Cartesian3.fromDegrees(lon + wrapOffset, p.lat, 5.0));
    }
    cachedRing = pts;
  }

  viewer.entities.add({
    polyline: {
      positions: new Cesium.CallbackProperty(() => cachedRing, false),
      width: 2.0,
      clampToGround: false,
      arcType: Cesium.ArcType.GEODESIC,
      material: new Cesium.PolylineGlowMaterialProperty({
        glowPower: 0.12,
        color: Cesium.Color.YELLOW.withAlpha(0.75)
      })
    }
  });

  /* ===================== HUD UPDATE ===================== */
  function updateHud(){
    utcEl.textContent = nowUTCString();

    updateStateCache();
    updateCoverageCache();

    if (!satrec) {
      latEl.textContent = lonEl.textContent = altEl.textContent = spdEl.textContent = "—";
      tleAgeEl.textContent = "—";
      return;
    }

    latEl.textContent = state.lat.toFixed(5) + "°";
    lonEl.textContent = normLon(state.lon).toFixed(5) + "°";
    altEl.textContent = state.altKm.toFixed(1) + " km";
    spdEl.textContent = state.speedKmS.toFixed(3) + " km/s";

    if (tleReceivedAt) {
      tleAgeEl.textContent = Math.floor((Date.now() - tleReceivedAt.getTime())/1000) + " s";
    }

    imuBox.textContent =
      `IMU (raw):  r=${imu.roll.toFixed(2)}  p=${imu.pitch.toFixed(2)}  y=${imu.yaw.toFixed(2)}\n` +
      `IMU (zero): ${imuZero ? `r=${imuZero.roll.toFixed(2)} p=${imuZero.pitch.toFixed(2)} y=${imuZero.yaw.toFixed(2)}` : "waiting…"}`;

    if (viewer.scene.mode === Cesium.SceneMode.SCENE2D && follow2D) {
      viewer.camera.setView({
        destination: Cesium.Cartesian3.fromDegrees(state.lon, state.lat, FOLLOW2D_HEIGHT_M)
      });
    }

    layoutMini();
  }

  viewer.scene.postRender.addEventListener(updateHud);
  setInterval(appendSamplesAhead, APPEND_EVERY_MS);

  /* ===================== POV ===================== */
  function setSatPOV(){
    setActive(btnSat);
    row2dOpts.style.display = "none";
    viewer.scene.morphTo3D(0.6);
    viewer.trackedEntity = satEntity;
    showMiniView(false);
    setStatus("Sat POV ✅");
  }

  // ✅ World POV = track satellite but with far camera offset (feels like Earth moves under it)
  function setWorldPOV(){
    setActive(btnWorld);
    row2dOpts.style.display = "none";
    viewer.scene.morphTo3D(0.6);
    viewer.trackedEntity = satEntity;
    showMiniView(true);

    viewer.zoomTo(satEntity, new Cesium.HeadingPitchRange(
      Cesium.Math.toRadians(20),
      Cesium.Math.toRadians(-35),
      WORLD_ALT
    ));

    setStatus("World POV ✅");
  }

  function fitWhole2DMap(){
    viewer.camera.flyTo({ destination: Cesium.Rectangle.MAX_VALUE, duration: 0.9 });
  }

  function set2DPOV(){
    setActive(btn2d);
    viewer.trackedEntity = undefined;
    viewer.scene.morphTo2D(0.8);
    row2dOpts.style.display = "flex";

    follow2D = false;
    set2dActive(btn2dZoom);
    showMiniView(true);
    setStatus("2D Zoom Out ✅");

    setTimeout(fitWhole2DMap, 250);
  }

  btn2dFollow.onclick = () => {
    follow2D = true;
    set2dActive(btn2dFollow);
    showMiniView(false);
    setStatus("2D Trace ✅");
  };

  btn2dZoom.onclick = () => {
    follow2D = false;
    set2dActive(btn2dZoom);
    showMiniView(true);
    setStatus("2D Zoom Out ✅");
    fitWhole2DMap();
  };

  btnSat.onclick = setSatPOV;
  btnWorld.onclick = setWorldPOV;
  btn2d.onclick = set2DPOV;

  setSatPOV();
  layoutMini();

  /* ===================== PASS PLANNER (kept minimal) ===================== */
  function fmtTime(d){ return d.toISOString().replace("T"," ").replace("Z"," UTC"); }

  function isOverIndia(lat, lon){
    const L = normLon(lon);
    return (
      lat >= INDIA_BBOX.latMin && lat <= INDIA_BBOX.latMax &&
      L   >= INDIA_BBOX.lonMin && L   <= INDIA_BBOX.lonMax
    );
  }

  function lookElevationDeg(date, obsLat, obsLon, obsAltM){
    if (!satrec) return null;
    const pv = satellite.propagate(satrec, date);
    if (!pv || !pv.position) return null;

    const gmst = satellite.gstime(date);
    const positionEcf = satellite.eciToEcf(pv.position, gmst);

    const observerGd = {
      latitude: Cesium.Math.toRadians(obsLat),
      longitude: Cesium.Math.toRadians(obsLon),
      height: obsAltM / 1000.0
    };

    const lookAngles = satellite.ecfToLookAngles(observerGd, positionEcf);
    return Cesium.Math.toDegrees(lookAngles.elevation);
  }

  function findNextGroundPass(startDate, horizonHours = 24, stepSec = 10, minElevDeg = 10){
    if (!satrec) return null;
    const end = new Date(startDate.getTime() + horizonHours * 3600 * 1000);

    let inPass = false;
    let aos = null, los = null;
    let maxEl = -999, tMax = null;

    for (let t = new Date(startDate); t <= end; t = new Date(t.getTime() + stepSec*1000)) {
      const elv = lookElevationDeg(t, GROUND_STATION.lat, GROUND_STATION.lon, GROUND_STATION.altM);
      if (elv == null) continue;

      const above = elv >= minElevDeg;

      if (!inPass && above) {
        inPass = true;
        aos = new Date(t);
        maxEl = elv; tMax = new Date(t);
      }

      if (inPass) {
        if (elv > maxEl) { maxEl = elv; tMax = new Date(t); }
        if (!above) {
          los = new Date(t);
          return { aos, los, maxEl, tMax };
        }
      }
    }
    return null;
  }

  function findNextIndiaOverflight(startDate, horizonHours = 24, stepSec = 20){
    if (!satrec) return null;

    const end = new Date(startDate.getTime() + horizonHours * 3600 * 1000);
    let inside = false;
    let enter = null, exit = null;

    for (let t = new Date(startDate); t <= end; t = new Date(t.getTime() + stepSec*1000)) {
      const s = propagateLLA(t);
      if (!s) continue;

      const isIn = isOverIndia(s.lat, s.lon);

      if (!inside && isIn) { inside = true; enter = new Date(t); }
      if (inside && !isIn) { exit = new Date(t); return { enter, exit }; }
    }
    return null;
  }

  async function showPassPlanner(){
    if (!satrec) {
      openModal("No TLE loaded yet.\n\nPublish a retained TLE to:\n" + TOPIC_TLE);
      return;
    }

    openModal("Computing next passes…");

    const now = new Date();
    const pass = findNextGroundPass(now, 24, 10, 10);
    const india = findNextIndiaOverflight(now, 24, 20);

    let text = "";
    text += `GROUND STATION: ${GROUND_STATION.name}\n`;
    text += `Location: ${GROUND_STATION.lat.toFixed(5)}, ${GROUND_STATION.lon.toFixed(5)}\n`;
    text += `Min elevation: 10°\n\n`;

    if (pass) {
      const durSec = Math.max(0, Math.floor((pass.los - pass.aos)/1000));
      text += `NEXT GS PASS (AOS → LOS)\n`;
      text += `AOS: ${fmtTime(pass.aos)}\n`;
      text += `LOS: ${fmtTime(pass.los)}\n`;
      text += `Duration: ${durSec} s\n`;
      text += `Max Elev: ${pass.maxEl.toFixed(1)}° @ ${fmtTime(pass.tMax)}\n\n`;
    } else {
      text += `NEXT GS PASS\nNo pass found within 24h.\n\n`;
    }

    text += `NEXT OVER-INDIA WINDOW (bbox)\n`;
    if (india) {
      const durSec = Math.max(0, Math.floor((india.exit - india.enter)/1000));
      text += `Enter: ${fmtTime(india.enter)}\n`;
      text += `Exit : ${fmtTime(india.exit)}\n`;
      text += `Duration: ${durSec} s\n`;
    } else {
      text += `No over-India crossing found within 24h.\n`;
    }

    openModal(text);
  }

  viewer.homeButton.viewModel.command.beforeExecute.addEventListener((e) => {
    e.cancel = true;
    viewer.camera.flyTo({
      destination: Cesium.Cartesian3.fromDegrees(GROUND_STATION.lon, GROUND_STATION.lat, 2.2e6),
      duration: 0.9
    });
    setTimeout(showPassPlanner, 250);
  });

  /* ===================== APPLY TLE ===================== */
  function setTLE(name, l1, l2){
    satName = name || "SAT";
    tleReceivedAt = new Date();
    satrec = satellite.twoline2satrec(l1, l2);

    tleBox.textContent = `${satName}\n${l1}\n${l2}`;
    setStatus("TLE loaded ✅");

    // reset IMU zero so it starts as 0,0,0 after new TLE (optional)
    // imuZero = null;

    seedSamples(new Date());

    // jump to current
    updateStateCache();

    if (btnWorld.classList.contains("active")) setWorldPOV();
    else if (btn2d.classList.contains("active")) set2DPOV();
    else setSatPOV();
  }

  /* ===================== MQTT ===================== */
  setStatus("Connecting MQTT…");
  mqEl.textContent = "Connecting…";
  setLive("RECONNECT");

  console.log("[MQTT] connecting:", MQTT_WSS_URL);

  const mqttClient = mqtt.connect(MQTT_WSS_URL, {
    clientId: "cubesat-tracker-" + Math.random().toString(16).slice(2),
    username: MQTT_USERNAME,
    password: MQTT_PASSWORD,
    protocol: "wss",
    keepalive: 30,
    reconnectPeriod: 2000,
    connectTimeout: 20000,
    clean: true,
    resubscribe: true
  });

  mqttClient.on("connect", () => {
    mqEl.textContent = "Connected ✅";
    setStatus("MQTT connected ✅");
    setLive("LIVE");

    mqttClient.subscribe(TOPIC_TLE, { qos: 1 }, (err) => { if (err) setStatus("Subscribe TLE error ❌"); });
    mqttClient.subscribe(TOPIC_IMU, { qos: 0 }, (err) => { if (err) setStatus("Subscribe IMU error ❌"); });
  });

  mqttClient.on("message", (topic, payload) => {
    const msg = payload.toString();

    if (topic === TOPIC_TLE) {
      const tle = parseTLEMessage(msg);
      if (!tle) { setStatus("Bad TLE format ❌"); return; }
      setTLE(tle.name, tle.l1, tle.l2);
      return;
    }

    if (topic === TOPIC_IMU) {
      try {
        const data = JSON.parse(msg);
        const r = Number(data.roll  ?? data.Roll  ?? data.roll_deg  ?? data.rollDeg);
        const p = Number(data.pitch ?? data.Pitch ?? data.pitch_deg ?? data.pitchDeg);
        const y = Number(data.yaw   ?? data.Yaw   ?? data.yaw_deg   ?? data.yawDeg);

        if (!Number.isNaN(r)) imu.roll = r;
        if (!Number.isNaN(p)) imu.pitch = p;
        if (!Number.isNaN(y)) imu.yaw = y;

        // ✅ first IMU packet sets zero reference so it starts at 0,0,0
        if (!imuZero) imuZero = { roll: imu.roll, pitch: imu.pitch, yaw: imu.yaw };
      } catch {}
    }
  });

  mqttClient.on("reconnect", () => {
    mqEl.textContent = "Reconnecting…";
    setStatus("MQTT reconnecting…");
    setLive("RECONNECT");
  });

  mqttClient.on("close", () => {
    mqEl.textContent = "Disconnected";
    setStatus("MQTT disconnected");
    setLive("OFFLINE");
  });

  mqttClient.on("offline", () => {
    mqEl.textContent = "Offline";
    setStatus("MQTT offline");
    setLive("OFFLINE");
  });

  mqttClient.on("error", (e) => {
    console.log("[MQTT] ERROR", e);
    mqEl.textContent = "Error";
    setStatus("MQTT error ❌");
    setLive("OFFLINE");
  });

  /* ===================== OPTIONAL: local test TLE if none arrives ===================== */
  // Uncomment to test without MQTT:
  /*
  setTimeout(() => {
    setTLE(
      "ISS (TEST)",
      "1 25544U 98067A   24001.53472222  .00016717  00000+0  10270-3 0  9002",
      "2 25544  51.6400  75.0000 0005400  90.0000  10.0000 15.50000000  9999"
    );
  }, 800);
  */
})();
</script>
</body>
</html>
